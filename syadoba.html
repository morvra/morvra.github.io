<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <link href='./Sv_icon.png' rel='icon' type='image/x-icon'/>
  <link href='./Sv_icon.png' rel='shortcut icon'/>
  <link href='./Sv_icon.png' rel='apple-touch-icon'/>
  <title>シャドウバースWB 対戦支援ツール</title>
  <style>
    /* 基本スタイル */
    body {
      font-family: sans-serif;
      background: #f7f9fb;
      color: #333;
      margin: 0;
      padding: 0;
    }
    main {
      padding: 8px;
      max-width: 1200px;
      margin: auto;
    }
    h2, h3 {
      color: #2c3e50;
      margin-top: 0;
    }

    /* レイアウト */
    .two-column-layout {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      justify-content: center;
    }

    .flex-column-item {
      width: 100%;
      box-sizing: border-box;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    /* PCレイアウト */
    @media (min-width: 984px) {
      .flex-column-item {
        width: auto;
        margin: 0;
        flex-basis: 0;
        min-width: 370px;
      }

      .counter-storage-column {
        flex-grow: 2;
        max-width: 336px;
      }

      .record-panel-column {
        flex-grow: 5;
        max-width: 840px;
      }

      .panel {
        height: fit-content;
      }
      .record-panel {
          display: flex;
          flex-direction: column;
          flex-grow: 1;
          height: auto;
          box-sizing: border-box;
      }
    }

    .panel {
      background: white;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.04);
      margin-bottom: 16px;
      width: 100%;
      box-sizing: border-box;
    }

    .record-panel h3,
    .record-panel .app-form,
    .record-panel .filter-controls {
        flex-shrink: 0;
    }

    /* カウンターコントロールグループ */
    .counter-control-group {
      align-items: center;
      margin-bottom: 12px;
    }
    .counter-control-group span.label {
      width: 200px;
      font-weight: 600;
      font-size: 15px;
    }
    .counter-control-group button {
      background: #ecf0f1;
      border: none;
      padding: 6px 12px;
      font-size: 18px;
      margin: 0 6px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .counter-control-group button:hover { background: #d0d7de; }
    .count-value {
      font-size: 18px;
      width: 40px;
      text-align: center;
    }

    /* フォーム要素 */
    .app-form input, .app-form select, .app-form textarea {
      width: 100%;
      max-width: 400px;
      padding: 8px;
      margin-top: 6px;
      margin-bottom: 16px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
      font-size: 14px;
    }
    .app-form label {
      display: block;
      font-weight: 500;
      margin-bottom: 4px;
    }
    .app-form textarea { resize: vertical; }

    /* フォームアクションボタン */
    .form-action-button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
      color: white;
    }
    .form-action-button.primary { background: #1abc9c; }
    .form-action-button.primary:hover { background: #16a085; }
    .form-action-button.secondary { background: #F39C12; color: white; }
    .form-action-button.secondary:hover { background: #d35400; }
    .form-action-button.neutral { background: #7f8c8d; }
    .form-action-button.neutral:hover { background: #5d6d7e; }
    .form-action-button.danger { background: #e74c3c; color: white; }
    .form-action-button.danger:hover { background: #c0392b; }

    /* トグルボタン */
    .toggle-button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .toggle-button-group button {
      background: #ecf0f1;
      border: 1px solid #ccc;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      color: #333;    
      transition: background 0.2s, border-color 0.2s;
    }
    .toggle-button-group button.active {
      background: #1abc9c;
      color: white;
      border-color: #16a085;
    }

    /* データテーブル */
    .data-table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      overflow: hidden;
      font-size: 14px;
      table-layout: fixed; /* テーブルレイアウトを固定 */
    }
    .data-table thead {
      background: #ecf0f1;
      font-weight: bold;
    }
    .data-table th, .data-table td {
      text-align: center;
      padding: 10px;
      border-bottom: 1px solid #eee;
      overflow: hidden; /* セル内のコンテンツがはみ出すのを防ぐ */
      white-space: nowrap; /* テキストの自動改行を無効化 */
    }
    .data-table tr:hover { background: #f9f9f9; }
    .data-table td:last-child button {
      background: #e74c3c;
      color: white;
      border: none;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .data-table td:last-child button:hover { background: #c0392b; }

    /* PP、カード名、メモの入力要素のスタイル */
    .data-table td input[type="text"],
    .data-table td input[type="number"],
    .data-table td textarea {
        width: 100%; /* 親要素の幅にフィット */
        box-sizing: border-box; /* paddingとborderをwidthに含める */
        border: 1px solid #ccc;
        padding: 4px;
        font-size: 14px;
        line-height: 1.2; /* テキストエリアの行の高さを調整 */
        display: block; /* ブロック要素として振る舞う */
        min-width: 0; /* デフォルトの最小幅を上書き */
    }
    .data-table td textarea {
        min-height: 40px; /* テキストエリアの最小高さを設定 */
        resize: vertical; /* 縦方向のみリサイズ可能 */
        overflow: hidden; /* テキストエリア自体のスクロールバーを非表示 */
    }


    /* 戦績テーブルのメモ欄 */
    #match-record-table th:nth-child(6),
    #match-record-table td:nth-child(6) {
      word-break: break-word; /* 単語の途中で改行を許可 */
      white-space: normal; /* 折り返しを許可 */
    }
    /* テキスト左寄せ */
    #match-record-table td:nth-child(6),
    #card-data-table td:nth-child(2) {
      text-align: left;
      word-break: break-word; /* 単語の途中で改行を許可 */
      white-space: normal; /* 折り返しを許可 */
    }

    /* 各テーブルの列幅を定義 */

    /* カードリストテーブルの列幅 */
    #card-data-table th:nth-child(1),
    #card-data-table td:nth-child(1) { width: 30px; } /* PP */
    #card-data-table th:nth-child(2),
    #card-data-table td:nth-child(2) { width: auto; } /* カード名&メモ */
    #card-data-table th:nth-child(3),
    #card-data-table td:nth-child(3) { width: 100px; } /* カウント */
    #card-data-table th:nth-child(4),
    #card-data-table td:nth-child(4) { width: 50px; } /* 削除 */

    /* 戦績記録テーブルの列幅 */
    #match-record-table th:nth-child(1),
    #match-record-table td:nth-child(1) { width: 120px; } /* 日時 */
    #match-record-table th:nth-child(2),
    #match-record-table td:nth-child(2) { width: 15%; } /* デッキ */
    #match-record-table th:nth-child(3),
    #match-record-table td:nth-child(3) { width: 10%; } /* 相手 */
    #match-record-table th:nth-child(4),
    #match-record-table td:nth-child(4) { width: 70px; } /* 先後 */
    #match-record-table th:nth-child(5),
    #match-record-table td:nth-child(5) { width: 70px; } /* 勝敗 */
    #match-record-table th:nth-child(6),
    #match-record-table td:nth-child(6) { width: auto; } /* メモ */
    #match-record-table th:nth-child(7),
    #match-record-table td:nth-child(7) { width: 50px; } /* 削除 */


    /* カードアクション */
    .card-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      margin-bottom: 12px;
    }
    .card-actions .form-action-button {
      padding: 6px 12px;
      font-size: 14px;
    }

    /* カード削除モード */
    .card-delete-button { display: none; }
    .delete-mode .card-delete-button { display: inline-block; }
    #card-data-table th:nth-child(4),
    #card-data-table td:nth-child(4) { display: none; }
    #counter-section.delete-mode #card-data-table th:nth-child(4),
    #counter-section.delete-mode #card-data-table td:nth-child(4) { display: table-cell; }

    /* データ管理パネル */
    .data-management-panel > h3 {
      color: #2c3e50;
      margin-top: 0;
      margin-bottom: 12px;
    }
    .data-management-panel .toggle-button-group { margin-bottom: 12px; }
    .data-management-panel .form-action-button {
      min-width: 96px;
      text-align: center;
    }
    .file-input-label { cursor: pointer; }
    .file-input-button {
      display: inline-block;
      background: #ecf0f1;
      border: 1px solid #ccc;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 14px;
      color: #333;
      user-select: none;
      min-width: 70px;
      text-align: center;
      transition: background 0.2s, border-color 0.2s;
    }
    .file-input-button:hover { background: #d0d7de; }
    .data-management-panel input[type="file"] { display: none; }
		
		/* Adsense */
    #ad {
		   text-align: center;
		   color: #aaa;
	     font-size: 90%;
			 max-width: 336px;
			 margin: 40px auto 24px;
		}

    /* タブナビゲーション */
    .tab-navigation {
      display: flex;
      margin-bottom: 20px;
      background: #e9ecef;
    }
    .tab-navigation-button {
      flex: 1;
      padding: 10px 5px;
      font-size: 15px;
      text-align: center;
      cursor: pointer;
      background: transparent;
      border: none;
      transition: background 0.3s, color 0.3s;
      font-weight: 600;
      color: #495057;
      -webkit-tap-highlight-color: transparent;
    }
    .tab-navigation-button:hover { background: #dee2e6; }
    .tab-navigation-button.active {
      background: #fff;
      color: #1abc9c;
    }

    /* フォームカラム */
    .form-columns {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    .form-left, .form-right {
      flex: 1;
      min-width: 250px;
    }

    /* フィルターコントロール */
    .filter-controls {
      margin-top: 20px;
      margin-bottom: 20px;
      padding: 0;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background-color: #fcfcfc;
      overflow: hidden;
    }
    .filter-controls details { border: none; }
    .filter-controls summary {
      padding: 16px;
      cursor: pointer;
      outline: none;
      font-weight: bold;
      color: #2c3e50;
      position: relative;
      list-style: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .filter-controls summary::marker,
    .filter-controls summary::-webkit-details-marker { display: none; }
    .filter-controls summary .filter-summary-title { margin: 0; font-size:18px; }
    .filter-controls summary .toggle-icon {
      display: inline-block;
      width: 20px;
      height: 20px;
      background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transition: transform 0.2s ease-in-out;
    }
    .filter-controls details[open] summary .toggle-icon { transform: rotate(180deg); }
	input#filter-deck-name-input {
      margin-top: 4px;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 14px;
    }

    .filter-content-wrapper {
      padding: 0 16px 16px 16px;
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.3s ease-out;
    }
    .filter-controls details[open] .filter-content-wrapper { max-height: 500px; }

    .filter-content-wrapper .app-form input[type="text"] { margin-bottom: 16px; }
    .filter-content-wrapper .form-action-button { margin-top: 15px; }

    /* カード追加フォームのレイアウト */
    .add-card-form-layout {
      margin-top:12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .add-card-form-layout input[type="number"] {
      width: 60px;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size:14px;
    }
    .add-card-form-layout input[type="text"] {
      flex: 1;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size:14px;
    }
    .add-card-form-layout .form-action-button {
      padding: 4px 16px;
      margin-top: -10px;
      font-size: 14px;
    }

    /* カードデータテーブルのボタン (PC用デフォルト) */
    #card-data-table td button {
        width: 24px;
        height: 24px;
        padding: 0;
        font-size: 18px;
	    color: #333;
        border-radius: 4px;
        border: 1px solid #ccc;
        background: #ecf0f1;
        transition: background 0.2s;
    }
    #card-data-table td button:hover { background: #d0d7de; }
    #card-data-table td button:first-child { margin-right: 6px; }
    #card-data-table td button:last-child { margin-left: 6px; }

    /* カードデータテーブルのカウント表示 (PC用デフォルト) */
    #card-data-table td span {
      display: inline-block;
      width: 24px;
      text-align: center;
    }

    .data-table th, .data-table td {
        padding: 6px;
        border-bottom: 1px solid #ddd;
    }
    .data-table thead tr { background:#ecf0f1; }
    .info-display {
      font-weight: bold;
      margin-bottom: 8px;
      min-height: 24px;
    }

    /* モバイルレイアウト */
    @media (max-width: 983px) {
      .tab-navigation {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        margin-bottom: 0;
        border-radius: 0;
        z-index: 1000;
        padding-bottom: env(safe-area-inset-bottom, 4px);
      }

      body {
        padding-bottom: calc(56px + env(safe-area-inset-bottom, 0px));
      }

      #match-record-table-wrapper { display: none; } /* デスクトップ用テーブル非表示 */
      #match-record-cards-container {
          display: flex;
          flex-direction: column;
          gap: 16px;
          margin-top: 16px;
      }

      .match-record-card {
          background: white;
          border-radius: 8px;
          padding: 12px;
          border: 1px solid #e0e0e0;
          display: flex;
          flex-direction: column;
          gap: 6px;
          position: relative;
          font-size: 14px;
      }

      .match-record-card .card-item {
          display: flex;
          align-items: flex-start;
      }

      .match-record-card .card-label {
          font-weight: bold;
          min-width: 50px;
          margin-right: 6px;
          color: #444;
      }

      .match-record-card .card-value {
          flex-grow: 1;
          word-break: break-word;
          font-size: 14px;
          white-space: normal; /* モバイルのメモも折り返しを許可 */
      }

      .match-record-card .delete-card-button {
          position: absolute;
          top: 6px;
          right: 6px;
          background: transparent;
          border: none;
          font-size: 16px;
          cursor: pointer;
          color: #e74c3c;
          padding: 4px;
          border-radius: 4px;
      }
      .match-record-card .delete-card-button:hover {
          color: #c0392b;
          background-color: #fce7e7;
      }
      
      /* モバイルでのテーブルセルパディングを調整 */
      .data-table th, .data-table td {
        padding: 8px 6px; /* 縦方向は8px、横方向は6pxに調整 */
      }

      /* カウント列のtdにflexboxを適用 */
      #card-data-table td:nth-child(3) { /* カウント列のtd */
          display: flex;
          align-items: center;
          justify-content: center;
          padding-left: 0; /* ボタンとspanが独自にスペースを持つためパディングを削除 */
          padding-right: 0;
      }

      /* モバイルでのカウンタボタンの調整 */
      #card-data-table td button {
          width: 40px; /* タッチしやすいサイズを維持しつつ、少し小さく */
          height: 40px;
          font-size: 22px; /* アイコンを少し小さく */
          padding: 0; /* フォントサイズでアイコンサイズを制御 */
          box-sizing: border-box; /* パディングをサイズに含める */
          vertical-align: middle; /* spanと位置を合わせる */
      }
      #card-data-table td button:first-child { margin-right: 4px; } /* マージンを調整 */
      #card-data-table td button:last-child { margin-left: 4px; }

      /* モバイルでのカウント数字の表示調整 */
      #card-data-table td span {
          font-size: 18px; /* カウントの文字サイズを調整 */
          padding: 0 2px; /* 左右のパディングで少しスペースを確保 */
          vertical-align: middle; /* ボタンと位置を合わせる */
      }
    }

    /* PCレイアウト（再定義） */
    @media (min-width: 984px) {
      .tab-navigation {
        position: static;
        margin-bottom: 20px;
        border-top: none;
      }
      body { padding-bottom: 0; }

      #match-record-table-wrapper {
          display: block;
          height: auto;
          flex-grow: 1;
          overflow-y: auto;
          max-height: 86vh;
      }
      #match-record-cards-container { display: none; }
      #load-more-records-button { display: none; }
    }

    /* インフォメーションボタンとツールチップ */
    .info-container {
      display: none; /* 通常は非表示 */
      position: fixed;
      right: 24px;
      bottom: 24px;
      z-index: 1010;
    }
    
    /* bodyに特定のクラスがある時だけ表示 */
    body.active-tab-storage-section .info-container {
      display: block;
    }

    .info-button {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background-color: #7f8c8d;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: bold;
      cursor: help;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: background-color 0.2s;
      user-select: none;
    }

    .info-button:hover {
      background-color: #5d6d7e;
    }

    .info-tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      bottom: 120%;
      right: 0;
      width: max-content;
      max-width: 320px;
      background-color: #2c3e50;
      color: #fff;
      text-align: left;
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.6;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      transition: opacity 0.3s ease, visibility 0.3s ease;
      pointer-events: none;
    }

    .info-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      right: 15px;
      border-width: 6px;
      border-style: solid;
      border-color: #2c3e50 transparent transparent transparent;
    }

    .info-container:hover .info-tooltip {
      visibility: visible;
      opacity: 1;
    }

    @media (max-width: 983px) {
      .info-container {
        bottom: calc(56px + env(safe-area-inset-bottom, 0px) + 20px);
        right: 20px;
      }
      .info-button {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
      .info-tooltip {
         font-size: 13px;
      }
    }

    /* 追加スタイル: 統計情報表示用 */
    .record-summary {
        display: flex;
        flex-direction: column; /* Changed to column for stats inside details */
        gap: 10px; /* Adjust spacing between elements */
        margin-top: 10px; /* Added margin to separate from filter controls */
    }

    .record-stats {
        display: flex;
        gap: 15px; /* Spacing between individual stats */
        flex-wrap: wrap;
        padding: 0; /* Remove padding as it's now inside the content wrapper */
    }

    .stat-item {
        white-space: nowrap; /* Prevent breaking lines within a stat item */
    }

    .stat-label {
        font-weight: normal; /* Less bold than the value */
        color: #555;
    }

    .stat-value {
        font-weight: bold;
        color: #2c3e50;
    }
  </style>
</head>

<body>
  <main>
    <div class="tab-navigation">
      <button class="tab-navigation-button active" data-tab="counter-section" aria-controls="counter-section" aria-selected="true">プレイ中</button>
      <button class="tab-navigation-button" data-tab="record-section" aria-controls="record-section" aria-selected="false">対戦記録</button>
      <button class="tab-navigation-button" data-tab="storage-section" aria-controls="storage-section" aria-selected="false">データ管理</button>
    </div>

    <div class="two-column-layout">
      <section class="panel flex-column-item counter-storage-column tab-content" id="counter-section">
          <div class="card-list-container">
              <h3>警戒カードリスト</h3>
              <div class="toggle-button-group class-filter-group" id="class-filter-group">
                <button type="button" data-class="エルフ">エルフ</button>
                <button type="button" data-class="ロイヤル">ロイヤル</button>
                <button type="button" data-class="ウィッチ">ウィッチ</button>
                <button type="button" data-class="ドラゴン">ドラゴン</button>
                <button type="button" data-class="ナイトメア">ナイトメア</button>
                <button type="button" data-class="ビショップ">ビショップ</button>
                <button type="button" data-class="ネメシス">ネメシス</button>
              </div>
              <div class="card-actions">
                <button type="button" id="reset-card-counts-button" class="form-action-button secondary">カウントをクリア</button>
                <button type="button" id="toggle-card-delete-mode-button" class="form-action-button neutral">削除モード OFF</button>
              </div>
              <div id="current-class-display" class="info-display"></div>
              <table id="card-data-table" class="data-table">
                <thead>
                  <tr>
                    <th>PP</th>
                    <th>カード名&メモ</th>
                    <th>カウント</th>
                    <th>削除</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
              <form id="add-card-form" class="app-form add-card-form-layout">
                <input type="number" id="new-card-pp-input" placeholder="PP" min="0" required>
                <input type="text" id="new-card-name-input" placeholder="カード名" required>
                <button type="submit" class="form-action-button primary">追加</button>
              </form>
          </div>
      </section>

      <section class="panel flex-column-item counter-storage-column tab-content" id="storage-section" style="display: none;">
          <div class="data-management-panel">
              <h3>エクスポート</h3>
              <div class="toggle-button-group">
                <button type="button" id="export-records-button" class="form-action-button secondary">戦績</button>
                <button type="button" id="export-cards-button" class="form-action-button secondary">カードリスト</button>
                <button type="button" id="export-all-data-button" class="form-action-button secondary">全体</button>
              </div>
              <h3>インポート</h3>
              <div class="toggle-button-group" style="margin-top: 10px;">
              <label class="file-input-label">
                  <span class="file-input-button">戦績</span>
                  <input type="file" id="import-records-file-input" accept=".json">
                </label>
                <label class="file-input-label">
                  <span class="file-input-button">カードリスト</span>
                  <input type="file" id="import-cards-file-input" accept=".json">
                </label>
                <label class="file-input-label">
                  <span class="file-input-button">全体</span>
                  <input type="file" id="import-all-data-file-input" accept=".json">
                </label>
              </div>
				<h3>戦績の削除</h3>
					<div class="toggle-button-group">
					  <button type="button" id="clear-records-button" class="form-action-button danger">
					    全削除
					  </button>
					</div>
          </div>
				<div id="ad">
					スポンサードリンク
					<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
							<!-- 記事下レスポンシブ -->
							<ins class="adsbygoogle"
									 style="display:block"
									 data-ad-client="ca-pub-3575252598876356"
									 data-ad-slot="6223968026"
									 data-ad-format="rectangle"></ins>
							<script>
							(adsbygoogle = window.adsbygoogle || []).push({});
							</script>
        </div>
      </section>

      <section class="panel record-panel tab-content flex-column-item record-panel-column" id="record-section" style="display: none;">
        <h3 style="flex-shrink: 0;">対戦記録</h3>
        <form id="add-record-form" class="app-form" style="flex-shrink: 0;">
          <div class="form-columns">
            <div class="form-left">
              <label for="my-deck-input">自分のデッキ</label>
              <input type="text" id="my-deck-input" name="deck" required>
              <label>相手のクラス</label>
              <div class="toggle-button-group" id="opponent-class-selection">
                <button type="button" data-value="エルフ">エルフ</button>
                <button type="button" data-value="ロイヤル">ロイヤル</button>
                <button type="button" data-value="ウィッチ">ウィッチ</button>
                <button type="button" data-value="ドラゴン">ドラゴン</button>
                <button type="button" data-value="ナイトメア">ナイトメア</button>
                <button type="button" data-value="ビショップ">ビショップ</button>
                <button type="button" data-value="ネメシス">ネメシス</button>
              </div>
            </div>
            <div class="form-right">
              <label>先後</label>
              <div class="toggle-button-group" id="turn-order-selection">
                <button type="button" data-value="先攻">先攻</button>
                <button type="button" data-value="後攻">後攻</button>
              </div>
              <label>勝敗</label>
              <div class="toggle-button-group" id="match-result-selection">
                <button type="button" data-value="⭕">勝ち</button>
                <button type="button" data-value="✖">負け</button>
              </div>
              <label for="record-memo-input">メモ</label>
              <textarea id="record-memo-input" name="memo" rows="2"></textarea>
            </div>
          </div>
          <button type="submit" class="form-action-button primary">記録する</button>
        </form>

        <div class="filter-controls" style="flex-shrink: 0;">
            <details id="record-filter-details">
                <summary>
                    <span class="filter-summary-title">戦績フィルター <span class="toggle-icon"></span></span>
                </summary>
                <div class="filter-content-wrapper">
                    <div class="form-columns">
                        <div class="form-left">
                            <label for="filter-deck-name-input">自分のデッキ名で絞り込み</label>
                            <input type="text" id="filter-deck-name-input" placeholder="デッキ名を入力">
                            <!-- New filter for turn order -->
                            <div style="display: box; margin-top: 8px;"><label style="margin-top: 15px;">先後で絞り込み</label></div>
                            <div class="toggle-button-group" id="filter-turn-order-selection">
                              <button type="button" data-value="">すべて</button>
                              <button type="button" data-value="先攻">先攻</button>
                              <button type="button" data-value="後攻">後攻</button>
                            </div>
                        </div>
                        <div class="form-right">
                            <label>相手のクラスで絞り込み</label>
                            <div class="toggle-button-group" id="filter-opponent-class-selection">
                              <button type="button" data-value="">すべて</button>
                              <button type="button" data-value="エルフ">エルフ</button>
                              <button type="button" data-value="ロイヤル">ロイヤル</button>
                              <button type="button" data-value="ウィッチ">ウィッチ</button>
                              <button type="button" data-value="ドラゴン">ドラゴン</button>
                              <button type="button" data-value="ナイトメア">ナイトメア</button>
                              <button type="button" data-value="ビショップ">ビショップ</button>
                              <button type="button" data-value="ネメシス">ネメシス</button>
                            </div>
                        </div>
                    </div>
                    <button type="button" id="clear-record-filters-button" class="form-action-button primary">フィルターをクリア</button>

                    <div class="record-summary">
                        <div class="record-stats">
                            <span class="stat-item"><span class="stat-label">試合数: </span><span id="total-matches-display" class="stat-value">0</span></span>
                            <span class="stat-item"><span class="stat-label">勝利数: </span><span id="total-wins-display" class="stat-value">0</span></span>
                            <span class="stat-item"><span class="stat-label">勝率: </span><span id="win-rate-display" class="stat-value">0.00%</span></span>
                        </div>
                    </div>
                </div>
            </details>
        </div>
    <h3 style="margin-bottom:8px;">記録一覧</h3>
		<div class="record-table-wrapper" id="match-record-table-wrapper">
        <table id="match-record-table" class="data-table">
          <thead>
            <tr>
              <th>日時</th>
              <th>デッキ</th>
              <th>相手</th>
              <th>先後</th>
              <th>勝敗</th>
              <th>メモ</th>
              <th>削除</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
		</div>
        <div id="match-record-cards-container">
            </div>
        <button id="load-more-records-button" class="form-action-button neutral" style="display: none; width: 100%; margin-top: 20px;">さらに表示</button>
      </section>
	</div>
  </main>

  <div class="info-container">
    <div class="info-button">i</div>
    <div class="info-tooltip">
      このツールは morvra によって個人で制作された、<br>
      Shadowverse: Worlds Beyond の非公式ファンツールです。<br>
      Cygames とは一切関係ありません。
    </div>
  </div>

  <script>
    // --- Local Storage Utility ---
    const Storage = {
      get: (key, defaultValue = null) => {
        try {
          const item = localStorage.getItem(key);
          return item ? JSON.parse(item) : defaultValue;
        } catch (e) {
          console.error(`Error getting item from localStorage for key "${key}":`, e);
          return defaultValue;
        }
      },
      set: (key, value) => {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
          console.error(`Error setting item to localStorage for key "${key}":`, e);
        }
      },
      remove: (key) => {
        try {
          localStorage.removeItem(key);
        } catch (e) {
          console.error(`Error removing item from localStorage for key "${key}":`, e);
        }
      },
      getAllKeys: (prefix) => {
        const keys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith(prefix)) {
            keys.push(key);
          }
        }
        return keys;
      }
    };

    // --- Debounce Utility ---
    const debounce = (func, delay) => {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
      };
    };

    // --- Local Storage Keys ---
    const LAST_TAB_KEY = 'svwb-last-tab';
    const RECORDS_KEY = 'svwb-records';
    const LAST_DECK_KEY = 'svwb-deck';
    const FILTER_DECK_KEY = 'svwb-filter-deck';
    const FILTER_CLASS_KEY = 'svwb-filter-class';
    const FILTER_TURN_KEY = 'svwb-filter-turn'; // New key for turn order filter
    const FILTER_OPEN_KEY = 'svwb-filter-open-state';
    const CARD_CLASS_PREFIX = 'svwb-cards-';


    // --- Tab Management Module ---
    const TabManager = (() => {
      const tabs = document.querySelectorAll('.tab-navigation-button');
      const panes = document.querySelectorAll('.tab-content');

      const showTab = (targetPaneId) => {
        // Remove existing tab state classes from body
        document.body.className = document.body.className.replace(/\bactive-tab-[\w-]+\b/g, '');
        // Add current tab state as a body class
        document.body.classList.add('active-tab-' + targetPaneId);

        Storage.set(LAST_TAB_KEY, targetPaneId);
        const isLargeScreen = window.matchMedia('(min-width: 984px)').matches;

        panes.forEach(pane => pane.style.display = 'none');
        tabs.forEach(t => {
            t.classList.remove('active');
            t.setAttribute('aria-selected', 'false');
        });

        if (isLargeScreen && (targetPaneId === 'counter-section' || targetPaneId === 'record-section')) {
          const counterPane = document.getElementById('counter-section');
          const recordPane = document.getElementById('record-section');
          const counterTabButton = document.querySelector(`.tab-navigation-button[data-tab="counter-section"]`);
          const recordTabButton = document.querySelector(`.tab-navigation-button[data-tab="record-section"]`);

          if (counterPane) counterPane.style.display = 'block';
          if (recordPane) {
            recordPane.style.display = 'flex';
            recordPane.style.flexDirection = 'column';
          }

          if (counterTabButton) {
              counterTabButton.classList.add('active');
              counterTabButton.setAttribute('aria-selected', 'true');
          }
          if (recordTabButton) {
              recordTabButton.classList.add('active');
              recordTabButton.setAttribute('aria-selected', 'true');
          }
        } else {
          const targetPane = document.getElementById(targetPaneId);
          if (targetPane) {
            if (targetPaneId === 'record-section') {
              targetPane.style.display = 'flex';
              targetPane.style.flexDirection = 'column';
            } else {
              targetPane.style.display = 'block';
            }
          }
          const targetTab = document.querySelector(`.tab-navigation-button[data-tab="${targetPaneId}"]`);
          if (targetTab) {
            targetTab.classList.add('active');
            targetTab.setAttribute('aria-selected', 'true');
          }
        }
      };

      const init = () => {
        tabs.forEach(tab => {
          tab.addEventListener('click', () => showTab(tab.dataset.tab));
        });

        const lastTab = Storage.get(LAST_TAB_KEY, 'counter-section');
        showTab(lastTab);

        window.addEventListener('resize', () => {
          const currentActiveTabId = Storage.get(LAST_TAB_KEY, 'counter-section');
          showTab(currentActiveTabId);
          RecordManager.applyFilters();
        });
      };

      return { init };
    })();

    // --- Toggle Button Group Management Module ---
    const ToggleButtonGroup = (() => {
      const init = () => {
        document.querySelectorAll('.toggle-button-group').forEach(group => {
          group.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
              group.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
              e.target.classList.add('active');
              // Dispatch a custom event to notify other modules about filter changes
              if (group.id.startsWith('filter-')) {
                  const event = new CustomEvent('filterChange', { detail: { groupId: group.id, value: e.target.dataset.value } });
                  document.dispatchEvent(event);
              }
            }
          });
        });
      };

      const getSelectedValue = (groupId) => {
        const active = document.querySelector(`#${groupId} .active`);
        return active ? active.dataset.value : '';
      };

      const setActiveButton = (groupId, value) => {
        const group = document.getElementById(groupId);
        if (group) {
          group.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.value === value) {
              btn.classList.add('active');
            }
          });
        }
      };

      return { init, getSelectedValue, setActiveButton };
    })();

    // --- Record Management Module ---
    const RecordManager = (() => {
      const recordsPerPage = 10;
      let currentDisplayCount = recordsPerPage;

      const matchRecordTableBody = document.querySelector('#match-record-table tbody');
      const addRecordForm = document.getElementById('add-record-form');
      const myDeckInput = document.getElementById('my-deck-input');
      const recordMemoInput = document.getElementById('record-memo-input');
      const filterDeckNameInput = document.getElementById('filter-deck-name-input');
      const clearRecordFiltersButton = document.getElementById('clear-record-filters-button');
      const recordFilterDetails = document.getElementById('record-filter-details');
      const matchRecordCardsContainer = document.getElementById('match-record-cards-container');
      const loadMoreButton = document.getElementById('load-more-records-button');

      // Elements for displaying statistics
      const totalMatchesDisplay = document.getElementById('total-matches-display');
      const totalWinsDisplay = document.getElementById('total-wins-display');
      const winRateDisplay = document.getElementById('win-rate-display');

      let allRecords = [];
      let filteredRecordsCache = [];

      /**
       * Adds data-label attributes to table cells for mobile responsiveness.
       */
      const addDataLabelsToRecordTable = () => {
        const headers = Array.from(document.querySelectorAll('#match-record-table th')).map(th => th.textContent);
        document.querySelectorAll('#match-record-table tbody tr').forEach(row => {
          Array.from(row.querySelectorAll('td')).forEach((td, index) => {
            if (headers[index] && index < headers.length -1) {
              td.dataset.label = headers[index];
            }
          });
        });
      };

      /**
       * Saves the current `allRecords` array to local storage.
       */
      const saveRecords = () => {
        const data = allRecords.map(record => ({
          timestamp: record.timestamp,
          date: record.date,
          deck: record.deck,
          opponent: record.opponent,
          firstSecond: record.firstSecond,
          result: record.result,
          memo: record.memo
        }));
        Storage.set(RECORDS_KEY, data);
      };

      /**
       * Loads records from local storage, sorts them by timestamp, and applies filters.
       */
      const loadRecords = () => {
        allRecords = Storage.get(RECORDS_KEY, []);
        allRecords.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        currentDisplayCount = recordsPerPage; // Reset display count on new load
        applyFilters();
      };

      /**
       * Calculates and displays match statistics (total matches, wins, win rate).
       * @param {Array} records The array of records to calculate statistics from.
       */
      const updateStatistics = (records) => {
          const totalMatches = records.length;
          const totalWins = records.filter(record => record.result === '⭕').length;
          const winRate = totalMatches > 0 ? ((totalWins / totalMatches) * 100).toFixed(2) : '0.00';

          totalMatchesDisplay.textContent = totalMatches;
          totalWinsDisplay.textContent = totalWins;
          winRateDisplay.textContent = `${winRate}%`;
      };

      /**
       * Applies current filters to `allRecords` and updates the displayed records and statistics.
       */
      const applyFilters = () => {
        matchRecordTableBody.innerHTML = '';
        matchRecordCardsContainer.innerHTML = '';

        const filterDeckName = filterDeckNameInput.value.toLowerCase();
        const filterOpponentClass = ToggleButtonGroup.getSelectedValue('filter-opponent-class-selection');
        // Get the selected value for the turn order filter
        const filterTurnOrder = ToggleButtonGroup.getSelectedValue('filter-turn-order-selection');

        // Filter records based on all criteria
        const filteredRecords = allRecords.filter(record => {
          const matchesDeck = record.deck.toLowerCase().includes(filterDeckName);
          const matchesClass = filterOpponentClass === '' || record.opponent === filterOpponentClass;
          // Add condition for turn order filter
          const matchesTurnOrder = filterTurnOrder === '' || record.firstSecond === filterTurnOrder;
          return matchesDeck && matchesClass && matchesTurnOrder;
        });
        filteredRecordsCache = filteredRecords; // Cache the filtered records

        updateStatistics(filteredRecordsCache); // Update statistics with filtered data

        const isLargeScreen = window.matchMedia('(min-width: 984px)').matches;

        if (isLargeScreen) {
            // Render all filtered records for desktop table
            filteredRecordsCache.forEach(entry => {
                matchRecordTableBody.appendChild(createRecordHtml(entry));
            });
            addDataLabelsToRecordTable(); // Re-apply data labels for desktop
            loadMoreButton.style.display = 'none'; // No "Load More" button on desktop
        } else {
            // Render a subset of filtered records for mobile cards
            const recordsToRender = filteredRecordsCache.slice(0, currentDisplayCount);
            recordsToRender.forEach(entry => {
                matchRecordCardsContainer.appendChild(createRecordHtml(entry));
            });

            // Show "Load More" button if there are more records to display
            if (filteredRecordsCache.length > currentDisplayCount) {
                loadMoreButton.style.display = 'block';
            } else {
                loadMoreButton.style.display = 'none';
            }
        }
      };

      /**
       * Makes a table cell editable.
       * @param {HTMLElement} td The table cell element.
       * @param {Object} entry The record object associated with the row.
       * @param {string} fieldName The name of the field to edit in the entry object.
       * @param {string} type The type of input element ('text' or 'textarea').
       */
      const makeEditableCell = (td, entry, fieldName, type = 'text') => { 
        td.addEventListener('click', () => {
          // If already editing, do nothing
          if (td.querySelector('input') || td.querySelector('textarea')) return;

          // Get the current value from the entry object directly when clicked
          const currentValue = entry[fieldName];

          const input = type === 'textarea' ? document.createElement('textarea') : document.createElement('input');
          if (type === 'text') input.type = 'text';
          input.value = currentValue; // Use currentValue
          Object.assign(input.style, { fontSize: '14px' });
          input.setAttribute('aria-label', `${fieldName}を編集`);
          
          td.textContent = ''; // Clear existing content
          td.appendChild(input);
          input.focus();

          // Function to finalize editing (save and update display), and remove input
          const finalizeEdit = () => {
            const val = input.value.trim();
            
            // Only update and save if the value has actually changed
            if (entry[fieldName] !== val) {
              entry[fieldName] = val; // Update the actual object in allRecords
              saveRecords(); // Save to localStorage
            }
            td.textContent = val; // Update the DOM with the new value
            if (input.parentNode === td) { // Ensure input is still a child before removing
                input.remove(); // Remove the input element from DOM
            }
          };

          // Event listener for when the input loses focus (e.g., click outside, tab out)
          input.addEventListener('blur', () => {
            finalizeEdit();
          });

          // Event listener for keyboard actions
          input.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') {
              if (type === 'textarea') {
                if (!ev.shiftKey) { // Enter without Shift key (save and exit)
                  ev.preventDefault(); // Prevent default Enter (newline)
                  finalizeEdit();      // Save changes and remove input
                }
                // If Shift+Enter, allow default newline behavior
              } else { // For text inputs (type === 'text')
                ev.preventDefault(); // Prevent form submission
                finalizeEdit();      // Save changes and remove input
              }
            } else if (ev.key === 'Escape') {
              td.textContent = currentValue; // Revert to original content using the value at click time
              if (input.parentNode === td) { // Ensure input is still a child before removing
                  input.remove(); // Remove the input without saving
              }
            }
          });
        });
      };

      /**
       * Creates HTML for a single record entry (either a table row or a mobile card).
       * @param {Object} entry The record object.
       * @returns {HTMLElement} The created HTML element.
       */
      const createRecordHtml = (entry) => {
          const isLargeScreen = window.matchMedia('(min-width: 984px)').matches;
          const formattedDate = new Date(entry.timestamp).toLocaleString('ja-JP', {
              year: 'numeric', month: '2-digit', day: '2-digit',
              hour: '2-digit', minute: '2-digit'
          }).replace(/\//g, '-');

          if (isLargeScreen) {
              const tr = document.createElement('tr');

              const tdDate = document.createElement('td');
              tdDate.textContent = formattedDate;
              tdDate.dataset.timestamp = entry.timestamp;
              tdDate.dataset.label = '日時';
              tr.appendChild(tdDate);

              const tdDeck = document.createElement('td');
              tdDeck.textContent = entry.deck;
              tdDeck.dataset.label = 'デッキ';
              makeEditableCell(tdDeck, entry, 'deck', 'text');
              tr.appendChild(tdDeck);

              const tdOpponent = document.createElement('td');
              tdOpponent.textContent = entry.opponent;
              tdOpponent.dataset.label = '相手';
              makeEditableCell(tdOpponent, entry, 'opponent', 'text');
              tr.appendChild(tdOpponent);

              const tdFirstSecond = document.createElement('td');
              tdFirstSecond.textContent = entry.firstSecond;
              tdFirstSecond.dataset.label = '先後';
              makeEditableCell(tdFirstSecond, entry, 'firstSecond', 'text');
              tr.appendChild(tdFirstSecond);

              const tdResult = document.createElement('td');
              tdResult.textContent = entry.result;
              tdResult.dataset.label = '勝敗';
              makeEditableCell(tdResult, entry, 'result', 'text');
              tr.appendChild(tdResult);

              const tdMemo = document.createElement('td');
              tdMemo.textContent = entry.memo;
              tdMemo.dataset.label = 'メモ';
              makeEditableCell(tdMemo, entry, 'memo', 'textarea');
              tr.appendChild(tdMemo);

              const delTd = document.createElement('td');
              const delBtn = document.createElement('button');
              delBtn.textContent = '🗑️';
              Object.assign(delBtn.style, { cursor: 'pointer', fontSize: '16px', border: 'none', background: 'transparent' });
              delBtn.title = '削除';
              delBtn.setAttribute('aria-label', `${formattedDate}の記録を削除`);
              delBtn.onclick = () => {
                const indexToRemove = allRecords.findIndex(rec => rec.timestamp === entry.timestamp);
                if (indexToRemove !== -1) {
                  allRecords.splice(indexToRemove, 1);
                  saveRecords();
                  applyFilters(); // Re-apply filters to update statistics and display
                }
              };
              delTd.appendChild(delBtn);
              tr.appendChild(delTd);

              return tr;

          } else {
              const cardDiv = document.createElement('div');
              cardDiv.classList.add('match-record-card');
              cardDiv.dataset.timestamp = entry.timestamp;

              const memoItem = document.createElement('div');
              memoItem.classList.add('card-item');
              memoItem.innerHTML = `<span class="card-label">メモ:</span> `;
              const memoValueSpan = document.createElement('span');
              memoValueSpan.classList.add('card-value');
              memoValueSpan.textContent = entry.memo;
              memoItem.appendChild(memoValueSpan);

              cardDiv.innerHTML = `
                  <div class="card-item"><span class="card-label">日時:</span> <span class="card-value">${formattedDate}</span></div>
                  <div class="card-item"><span class="card-label">デッキ:</span> <span class="card-value">${entry.deck}</span></div>
                  <div class="card-item"><span class="card-label">相手:</span> <span class="card-value">${entry.opponent}</span></div>
                  <div class="card-item"><span class="card-label">先後:</span> <span class="card-value">${entry.firstSecond}</span></div>
                  <div class="card-item"><span class="card-label">勝敗:</span> <span class="card-value">${entry.result}</span></div>
              `;
              cardDiv.appendChild(memoItem);

              const deleteButton = document.createElement('button');
              deleteButton.classList.add('delete-card-button');
              deleteButton.title = '削除';
              deleteButton.textContent = '🗑️';
              deleteButton.setAttribute('aria-label', `${formattedDate}の記録を削除`);
              cardDiv.appendChild(deleteButton);

              deleteButton.addEventListener('click', () => {
                  const indexToRemove = allRecords.findIndex(rec => rec.timestamp === cardDiv.dataset.timestamp);
                  if (indexToRemove !== -1) {
                      allRecords.splice(indexToRemove, 1);
                      saveRecords();
                      applyFilters(); // Re-apply filters to update statistics and display
                  }
              });

              return cardDiv;
          }
      };

      /**
       * Adds a new record entry.
       * @param {string} deck My deck name.
       * @param {string} opponent Opponent's class.
       * @param {string} firstSecond First or second turn.
       * @param {string} result Match result ('⭕' for win, '✖' for loss).
       * @param {string} memo Optional memo.
       */
      const addRecordEntry = (deck, opponent, firstSecond, result, memo) => {
        const newRecord = {
          timestamp: new Date().toISOString(),
          date: new Date().toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }).replace(/\//g, '-'),
          deck,
          opponent,
          firstSecond,
          result,
          memo
        };
        allRecords.unshift(newRecord); // Add to the beginning of the array
        saveRecords();
        currentDisplayCount = recordsPerPage; // Reset display count after adding a new record
        applyFilters(); // Re-apply filters to update statistics and display
      };

      /**
       * Handles the submission of the record form.
       * @param {Event} e The submit event.
       */
      const handleRecordSubmit = (e) => {
        e.preventDefault();
        const deck = myDeckInput.value;
        const opponent = ToggleButtonGroup.getSelectedValue('opponent-class-selection');
        const firstSecond = ToggleButtonGroup.getSelectedValue('turn-order-selection');
        const result = ToggleButtonGroup.getSelectedValue('match-result-selection');
        const memo = recordMemoInput.value;

        if (!opponent || !firstSecond || !result) {
          // Use a custom modal instead of alert in production
          alert('すべて選択してください');
          return;
        }

        addRecordEntry(deck, opponent, firstSecond, result, memo);
        Storage.set(LAST_DECK_KEY, deck);
        recordMemoInput.value = '';
        document.querySelectorAll('#opponent-class-selection button.active, #turn-order-selection button.active, #match-result-selection button.active').forEach(btn => {
          btn.classList.remove('active');
        });
      };

      /**
       * Loads more records for mobile display.
       */
      const loadMoreRecords = () => {
          const oldDisplayCount = currentDisplayCount;
          currentDisplayCount += recordsPerPage;

          const isLargeScreen = window.matchMedia('(min-width: 984px)').matches;

          if (!isLargeScreen) {
              const newRecordsToAppend = filteredRecordsCache.slice(oldDisplayCount, currentDisplayCount);
              newRecordsToAppend.forEach(entry => {
                  matchRecordCardsContainer.appendChild(createRecordHtml(entry));
              });

              if (filteredRecordsCache.length > currentDisplayCount) {
                  loadMoreButton.style.display = 'block';
              } else {
                  loadMoreButton.style.display = 'none';
              }
          } else {
              applyFilters(); // Re-apply filters to ensure full table update
          }
      };

      // Debounce the loadRecords call to prevent excessive updates on rapid input
      const debouncedLoadRecords = debounce(loadRecords, 300);

      /**
       * Initializes the RecordManager module.
       */
      const init = () => {
        const lastDeck = Storage.get(LAST_DECK_KEY);
        if (lastDeck) myDeckInput.value = lastDeck;

        // Load and set initial filter states from storage
        filterDeckNameInput.value = Storage.get(FILTER_DECK_KEY, '');
        ToggleButtonGroup.setActiveButton('filter-opponent-class-selection', Storage.get(FILTER_CLASS_KEY, ''));
        // Set initial state for the new turn order filter
        ToggleButtonGroup.setActiveButton('filter-turn-order-selection', Storage.get(FILTER_TURN_KEY, ''));


        loadRecords(); // Initial load of records and display

        addRecordForm.addEventListener('submit', handleRecordSubmit);

        // Event listeners for filter inputs
        filterDeckNameInput.addEventListener('input', () => {
            Storage.set(FILTER_DECK_KEY, filterDeckNameInput.value); // Save filter state
            debouncedLoadRecords(); // Debounced load
        });
        document.addEventListener('filterChange', (e) => {
            if (e.detail.groupId === 'filter-opponent-class-selection') {
                Storage.set(FILTER_CLASS_KEY, e.detail.value); // Save filter state
                loadRecords(); // Direct load for toggle buttons
            } else if (e.detail.groupId === 'filter-turn-order-selection') { // Handle turn order filter changes
                Storage.set(FILTER_TURN_KEY, e.detail.value);
                loadRecords();
            }
        });
        clearRecordFiltersButton.addEventListener('click', () => {
            filterDeckNameInput.value = '';
            ToggleButtonGroup.setActiveButton('filter-opponent-class-selection', '');
            ToggleButtonGroup.setActiveButton('filter-turn-order-selection', ''); // Clear new turn order filter
            Storage.remove(FILTER_DECK_KEY);
            Storage.remove(FILTER_CLASS_KEY);
            Storage.remove(FILTER_TURN_KEY); // Remove new turn order filter from storage
            loadRecords(); // Clear filters and reload
        });

        // Manage filter details open/close state
        if (recordFilterDetails) {
          const isFilterOpen = Storage.get(FILTER_OPEN_KEY, false);
          if (isFilterOpen) {
            recordFilterDetails.setAttribute('open', '');
          } else {
            recordFilterDetails.removeAttribute('open');
          }

          recordFilterDetails.addEventListener('toggle', () => {
            Storage.set(FILTER_OPEN_KEY, recordFilterDetails.open);
          });
        }

        loadMoreButton.addEventListener('click', loadMoreRecords);
      };

      return { init, loadRecords, applyFilters };
    })();

    // --- Card List Management Module ---
    const CardListManager = (() => {
      const classFilterGroup = document.getElementById('class-filter-group');
      const currentClassDisplay = document.getElementById('current-class-display');
      const cardDataTableBody = document.querySelector('#card-data-table tbody');
      const addCardForm = document.getElementById('add-card-form');
      const newCardPpInput = document.getElementById('new-card-pp-input');
      const newCardNameInput = document.getElementById('new-card-name-input');
      const resetCardCountsButton = document.getElementById('reset-card-counts-button');
      const toggleCardDeleteModeButton = document.getElementById('toggle-card-delete-mode-button');
      const counterSection = document.getElementById('counter-section');

      let currentClass = '';
      let allCardData = {};

      /**
       * Saves card data for a specific class to local storage.
       * @param {string} className The name of the class.
       */
      const saveCards = (className) => {
        if (!className) return;
        Storage.set(CARD_CLASS_PREFIX + className, allCardData[className] || []);
      };

      /**
       * Loads card data for a specific class from local storage.
       * @param {string} className The name of the class.
       * @returns {Array} The array of card objects.
       */
      const loadCards = (className) => {
        if (!className) return [];
        return Storage.get(CARD_CLASS_PREFIX + className, []);
      };

      /**
       * Loads all card data for all classes into `allCardData`.
       */
      const loadAllClassCards = () => {
        const classNames = ["エルフ", "ロイヤル", "ウィッチ", "ドラゴン", "ナイトメア", "ビショップ", "ネメシス"];
        classNames.forEach(name => {
            allCardData[name] = loadCards(name);
        });
        if (currentClass) {
            renderCardList(); // Re-render if a class is currently selected
        }
      };

      /**
       * Sorts an array of card objects by PP.
       * @param {Array} cards The array of card objects.
       * @returns {Array} The sorted array.
       */
      const sortCards = (cards) => {
        return cards.sort((a, b) => a.pp - b.pp);
      };

      /**
       * Renders the card list for the `currentClass` in the table.
       */
      const renderCardList = () => {
        cardDataTableBody.innerHTML = ''; // Clear existing list
        if (!currentClass) {
          currentClassDisplay.textContent = '';
          return;
        }
        currentClassDisplay.textContent = `クラス: ${currentClass}`;

        const cards = allCardData[currentClass] || [];
        sortCards(cards);

        cards.forEach((card, index) => {
          const tr = document.createElement('tr');

          // PP cell (editable)
          const tdPP = document.createElement('td');
          tdPP.textContent = card.pp;
          tdPP.style.cursor = 'pointer';
          tdPP.title = 'クリックで編集';
          tdPP.addEventListener('click', () => {
            if (tdPP.querySelector('input')) return; // Prevent multiple inputs
            const input = document.createElement('input');
            input.type = 'number';
            input.min = '0';
            input.value = card.pp;
            Object.assign(input.style, { fontSize: '14px' });
            input.setAttribute('aria-label', `カードPPを編集: ${card.name}`);
            tdPP.textContent = '';
            tdPP.appendChild(input);
            input.focus();
            const finishEdit = () => {
              let val = parseInt(input.value, 10);
              if (isNaN(val) || val < 0) val = 0;
              card.pp = val;
              renderCardList(); // Re-render to sort and update display
              saveCards(currentClass);
            };
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (ev) => {
              if (ev.key === 'Enter') finishEdit();
              else if (ev.key === 'Escape') renderCardList(); // Revert on escape
            });
          });
          tr.appendChild(tdPP);

          // Card Name cell (editable)
          const tdName = document.createElement('td');
          tdName.textContent = card.name;
          tdName.style.cursor = 'pointer';
          tdName.title = 'クリックで編集';
          tdName.addEventListener('click', () => {
            if (tdName.querySelector('input')) return; // Prevent multiple inputs
            const input = document.createElement('input');
            input.type = 'text';
            input.value = card.name;
            Object.assign(input.style, { fontSize: '14px' });
            input.setAttribute('aria-label', `カード名を編集: ${card.name}`);
            tdName.textContent = '';
            tdName.appendChild(input);
            input.focus();
            const finishEdit = () => {
              const val = input.value.trim();
              card.name = val || '(無名カード)'; // Default name if empty
              renderCardList(); // Re-render to sort and update display
              saveCards(currentClass);
            };
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', (ev) => {
              if (ev.key === 'Enter') finishEdit();
              else if (ev.key === 'Escape') renderCardList(); // Revert on escape
            });
          });
          tr.appendChild(tdName);

          // Count control buttons and display
          const tdCount = document.createElement('td');
          const btnMinus = document.createElement('button');
          btnMinus.textContent = '−';
          btnMinus.setAttribute('aria-label', `${card.name}のカウントを減らす`);
          btnMinus.addEventListener('click', (e) => {
            e.preventDefault();
            if (card.count > 0) {
              card.count--;
              renderCardList();
              saveCards(currentClass);
            }
          });
          const spanCount = document.createElement('span');
          spanCount.textContent = card.count;
          spanCount.setAttribute('aria-live', 'polite'); // Announce changes to screen readers
          const btnPlus = document.createElement('button');
          btnPlus.textContent = '+';
          btnPlus.setAttribute('aria-label', `${card.name}のカウントを増やす`);
          btnPlus.addEventListener('click', (e) => {
            e.preventDefault();
            card.count++;
            renderCardList();
            saveCards(currentClass);
          });
          tdCount.appendChild(btnMinus);
          tdCount.appendChild(spanCount);
          tdCount.appendChild(btnPlus);
          tr.appendChild(tdCount);

          // Delete button (visible in delete mode)
          const tdDel = document.createElement('td');
          const btnDel = document.createElement('button');
          btnDel.classList.add('card-delete-button');
          btnDel.textContent = '🗑️';
          Object.assign(btnDel.style, { cursor: 'pointer', fontSize: '16px', border: 'none', background: 'transparent' });
          btnDel.title = '削除';
          btnDel.setAttribute('aria-label', `${card.name}をリストから削除`);
          btnDel.addEventListener('click', (e) => {
            e.preventDefault();
            allCardData[currentClass].splice(index, 1); // Remove from array
            renderCardList(); // Re-render
            saveCards(currentClass);
          });
          tdDel.appendChild(btnDel);
          tr.appendChild(tdDel);

          cardDataTableBody.appendChild(tr);
        });
      };

      /**
       * Handles selection of a card class button.
       * @param {Event} e The click event.
       */
      const handleClassSelection = (e) => {
        if (e.target.tagName !== 'BUTTON') return;
        classFilterGroup.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        e.target.classList.add('active');
        currentClass = e.target.dataset.class;
        allCardData[currentClass] = loadCards(currentClass); // Ensure current class data is loaded
        renderCardList();
      };

      /**
       * Handles adding a new card to the current class list.
       * @param {Event} e The submit event.
       */
      const handleCardAdd = (e) => {
        e.preventDefault();
        if (!currentClass) {
          // Use a custom modal instead of alert in production
          alert('まず左上のクラスを選択してください');
          return;
        }
        let ppVal = parseInt(newCardPpInput.value, 10);
        if (isNaN(ppVal) || ppVal < 0) {
          // Use a custom modal instead of alert in production
          alert('PPは0以上の整数を入力してください');
          newCardPpInput.focus();
          return;
        }
        let nameVal = newCardNameInput.value.trim();
        if (!nameVal) {
          // Use a custom modal instead of alert in production
          alert('カード名を入力してください');
          newCardNameInput.focus();
          return;
        }
        if (!allCardData[currentClass]) allCardData[currentClass] = []; // Initialize if empty
        allCardData[currentClass].push({pp: ppVal, name: nameVal, count: 0});
        allCardData[currentClass] = sortCards(allCardData[currentClass]); // Sort after adding
        saveCards(currentClass);
        renderCardList();
        addCardForm.reset(); // Clear form
        newCardPpInput.focus(); // Focus on PP input
      };

      /**
       * Resets counts of all cards in the current class to 0.
       */
      const resetCounts = () => {
        // Use a custom modal instead of confirm in production
        if (!currentClass || !allCardData[currentClass] || !confirm(`本当に${currentClass}のカードカウントをすべてクリアしますか？`)) return;
        allCardData[currentClass].forEach(card => {
          card.count = 0;
        });
        saveCards(currentClass);
        renderCardList();
        // Use a custom modal instead of alert in production
        alert(`${currentClass}のカードカウントをクリアしました。`);
      };

      /**
       * Toggles card deletion mode (shows/hides delete buttons).
       */
      const toggleDeleteMode = () => {
        const isActive = counterSection.classList.toggle('delete-mode');
        toggleCardDeleteModeButton.textContent = isActive ? '削除モード ON' : '削除モード OFF';
        toggleCardDeleteModeButton.setAttribute('aria-pressed', isActive);
      };

      /**
       * Initializes the CardListManager module.
       */
      const init = () => {
        classFilterGroup.addEventListener('click', handleClassSelection);
        addCardForm.addEventListener('submit', handleCardAdd);
        resetCardCountsButton.addEventListener('click', resetCounts);
        toggleCardDeleteModeButton.addEventListener('click', toggleDeleteMode);
        toggleCardDeleteModeButton.setAttribute('aria-pressed', 'false'); // Initial aria state

        loadAllClassCards(); // Load all stored card data

        // Select the first class by default if no class is active
        const firstBtn = classFilterGroup.querySelector('button');
        if (firstBtn && !classFilterGroup.querySelector('.active')) {
          firstBtn.click();
        }
      };

      return { init, getAllCardData: () => allCardData, CLASS_PREFIX: CARD_CLASS_PREFIX, renderCardList, loadAllClassCards };
    })();

    // --- Data Import/Export Management Module ---
    const DataManager = (() => {
      /**
       * Exports data as a JSON file.
       * @param {string} filename The name of the file to download.
       * @param {Object|Array} data The data to export.
       */
      const exportAsJson = (filename, data) => {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      /**
       * Reads a JSON file from an input element and calls a callback with its parsed content.
       * @param {HTMLInputElement} inputEl The file input element.
       * @param {function(Object|Array): void} callback The callback function to receive the parsed data.
       */
      const readJsonFile = (inputEl, callback) => {
        const file = inputEl.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const data = JSON.parse(reader.result);
            callback(data);
          } catch (e) {
            // Use a custom modal instead of alert in production
            alert('読み込み失敗：JSONの形式が不正なファイルです。コンソールで詳細を確認してください。');
            console.error('JSON parse error:', e);
          }
        };
        reader.readAsText(file);
      };

      /**
       * Initializes the DataManager module.
       */
      const init = () => {
        // Export buttons
        document.getElementById('export-records-button').addEventListener('click', () => {
          const records = Storage.get(RECORDS_KEY, []);
          exportAsJson(`svwb_records_${new Date().toISOString().slice(0,10)}.json`, records);
        });

        document.getElementById('export-cards-button').addEventListener('click', () => {
          const cards = CardListManager.getAllCardData(); // This returns { "エルフ": [...], "ロイヤル": [...] }
          exportAsJson(`svwb_cards_${new Date().toISOString().slice(0,10)}.json`, cards);
        });

        document.getElementById('export-all-data-button').addEventListener('click', () => {
          const records = Storage.get(RECORDS_KEY, []);
          const cards = CardListManager.getAllCardData(); // This returns { "エルフ": [...], "ロイヤル": [...] }
          exportAsJson(`svwb_all_${new Date().toISOString().slice(0,10)}.json`, { records, cards });
        });

        // Import files
        document.getElementById('import-records-file-input').addEventListener('change', (e) => {
          readJsonFile(e.target, (data) => {
            if (!Array.isArray(data)) {
                // Use a custom modal instead of alert in production
                alert('戦績データが不正です: ファイルの内容が配列形式ではありません。');
                return;
            }
            Storage.set(RECORDS_KEY, data);
            RecordManager.loadRecords(); // Reload records after import
            // Use a custom modal instead of alert in production
            alert('戦績をインポートしました。');
            e.target.value = ''; // Clear file input
          });
        });

        document.getElementById('import-cards-file-input').addEventListener('change', (e) => {
          readJsonFile(e.target, (data) => {
            if (typeof data !== 'object' || data === null) {
              // Use a custom modal instead of alert in production
              alert('カードデータが不正です: ファイルの内容がオブジェクト形式ではありません。');
              return;
            }
            let importedCount = 0;
            for (const className in data) { // 'className' will be 'エルフ', 'ロイヤル' etc.
              if (Array.isArray(data[className])) { // Check if value is an array
                Storage.set(CARD_CLASS_PREFIX + className, data[className]); // Save with prefix
                importedCount++;
              }
            }
            CardListManager.loadAllClassCards(); // Reload all card data after import
            if (importedCount > 0) {
              // Use a custom modal instead of alert in production
              alert('カードリストをインポートしました。');
            } else {
              // Use a custom modal instead of alert in production
              alert('インポートする有効なカードデータが見つかりませんでした。ファイル形式を確認してください。');
            }
            e.target.value = ''; // Clear file input
          });
        });

        document.getElementById('import-all-data-file-input').addEventListener('change', (e) => {
          readJsonFile(e.target, (data) => {
            if (!data || typeof data !== 'object') {
                // Use a custom modal instead of alert in production
                alert('全体データが不正です: ファイルの内容がオブジェクト形式ではありません。');
                return;
            }
            if (Array.isArray(data.records)) {
              Storage.set(RECORDS_KEY, data.records);
            } else {
                console.warn('全体データに有効な戦績データ（records）が見つかりませんでした。');
            }

            if (typeof data.cards === 'object' && data.cards !== null) {
              let importedCardClassesCount = 0;
              // Loop through the class names within data.cards
              for (const className in data.cards) { // 'className' will be 'エルフ', 'ロイヤル' etc.
                if (Array.isArray(data.cards[className])) { // Check if value is an array
                  Storage.set(CARD_CLASS_PREFIX + className, data[className]); // Save with prefix
                  importedCardClassesCount++;
                }
              }
              if (importedCardClassesCount === 0) {
                console.warn('全体データに有効なカードクラス（cards）が見つかりませんでした。');
              }
            } else {
                console.warn('全体データに有効なカードデータ（cards）が見つかりませんでした。');
            }

            RecordManager.loadRecords(); // Reload records and update statistics
            CardListManager.loadAllClassCards(); // Reload all card data
            // Use a custom modal instead of alert in production
            alert('全体データをインポートしました。');
            e.target.value = ''; // Clear file input
          });
        });

        // Clear records
        document.getElementById('clear-records-button').addEventListener('click', () => {
          // Use a custom modal instead of confirm in production
          if (confirm('本当に戦績をすべて削除しますか？')) {
            Storage.remove(RECORDS_KEY);
            RecordManager.loadRecords(); // Reload records (will be empty) and update statistics
            // Use a custom modal instead of alert in production
            alert('戦績を削除しました。');
          }
        });
      };

      return { init };
    })();

    // Initialize all modules when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      TabManager.init();
      ToggleButtonGroup.init();
      RecordManager.init();
      CardListManager.init();
      DataManager.init();
    });
  </script>
</body>
</html>
