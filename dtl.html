<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="DTL" />
    <title>DailyTaskList</title>
    <script src="https://cdn.tailwindcss.com"></script>
	<link href='./dtlfavicon.ico' rel='icon' type='image/x-icon'/>
    <link href='./dtlicon.png' rel='shortcut icon'/>
    <link href='./dtlicon.png' rel='apple-touch-icon'/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        
        /* header for desktop */
        @media (min-width: 769px) {
            .header {
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
				position: fixed;
				width: 100%;
		        top: 0;
		        z-index: 1;
            }
			body { padding-top: 110px; }
			.sections-wrapper { padding-bottom:88px; }
        }
        
        /* Compact header for mobile */
        @media (max-width: 768px) {
            .header {
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .mobile-compact-header .header-content {
                padding: 8px 16px !important;
                flex-direction: row !important;
                align-items: center !important;
            }
            .mobile-compact-header h1 {
                display: none;
            }
			p#current-date { color: #333; font-size: 1rem; }
            .mobile-compact-header .header-stats p:first-child {
                font-size: 0.7rem;
            }
            .mobile-compact-header .header-stats p:last-child {
                font-size: 1.1rem;
            }
            .mobile-nav {
                padding: 0 !important;
            }
            .mobile-nav .tab-link {
                padding: 6px 12px !important;
                font-size: 0.8rem !important;
            }
        }
        
        .tab-link.active { border-color: #3b82f6; background-color:#3b82f6; color:white; }
        .tab-content { display:none; }
        .tab-content.active { display:block; }
        .task-row.focused { background-color: #fef9c3; }
        .task-card.focused { background-color: #fef9c3; border-color: #eab308; }
        ::-webkit-scrollbar { width:8px; height:0px; }
        ::-webkit-scrollbar-track { background:#f1f1f1; border-radius:10px; }
        ::-webkit-scrollbar-thumb { background:#888; border-radius:10px; }
        ::-webkit-scrollbar-thumb:hover { background:#555; }

        .timer-btn {
            height: 33px;
            width: 33px;
            min-height: 33px;
            min-width: 33px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }
        .task-table th, .task-table td {
             padding-top: 0.25rem;
             padding-bottom: 0.25rem;
             padding-left: 0.5rem;
             padding-right: 0.5rem;
        }
        
        .small-btn { min-height:44px; min-width:44px; display:inline-flex; align-items:center; justify-content:center; }
        .add-task-fab { display:block; position:fixed; right:16px; bottom:16px; z-index:60; }
        .sync-data-fab { display:none; position:fixed; left:16px; bottom:16px; z-index:60; }
        .inline-input, .inline-select { width:100%; box-sizing:border-box; padding:6px 8px; border-radius:6px; border:1px solid #d1d5db; }
        .small-btn { padding:6px 8px; border-radius:6px; font-size:0.9rem; }

        .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); }
        .modal.active { display:flex; align-items:center; justify-content:center; }
        .modal-content { background:white; border-radius:8px; max-width:90vw; max-height:90vh; overflow-y:auto; }

        .tooltip-container { position: relative; display: inline-flex; align-items: center; }
        .custom-tooltip { visibility: hidden; opacity: 0; background-color: #2d3748; color: #fff; text-align: left; border-radius: 6px; padding: 8px 12px; position: absolute; z-index: 10; bottom: 150%; left: 50%; transform: translateX(-50%); transition: opacity 0.1s, visibility 0.1s; width: max-content; max-width: 300px; font-size: 0.875rem; font-weight: normal; line-height: 1.4; white-space: pre-wrap; box-shadow: 0 4px 6px rgba(0,0,0,0.1); pointer-events: none; }
        .custom-tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #2d3748 transparent transparent transparent; }
        
        .tooltip-container:hover .custom-tooltip { 
            visibility: visible; 
            opacity: 1; 
            transition-delay: 0.1s; 
        }
        .tooltip-container:hover .custom-tooltip.tooltip-top { 
            bottom: 150%; 
            top: auto; 
        }
        .tooltip-container:hover .custom-tooltip.tooltip-bottom { 
            top: 150%; 
            bottom: auto; 
        }
        .custom-tooltip.tooltip-bottom::after { 
            top: -10px; 
            bottom: auto; 
            border-color: transparent transparent #2d3748 transparent; 
        }

        .dragging { opacity: 0.5; background-color: #fef9c3; }
        .drag-over { background-color: #e0f2fe; }
        .drag-handle { cursor: move; color: #9ca3af; }
        .drag-handle:hover { color: #6b7280; }

        .archive-tabs { border-bottom: 1px solid #e5e7eb; }
        .archive-tab { padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent; }
        .archive-tab.active { border-bottom-color: #3b82f6; background-color: #eff6ff; }
        .archive-tab:hover { background-color: #f3f4f6; }

        .time-input { width: 80px; text-align: center; border: 1px solid #d1d5db; border-radius: 4px; padding: 2px 4px; }

		.archive-search-box { display:flex; gap:8px; align-items:center; margin-bottom:12px; }
        .archive-search-input { flex:1; padding:8px 10px; max-width: 50%; border-radius:6px; border:1px solid #d1d5db; background:white; }
        .archive-search-btn { padding:8px 12px; border-radius:6px; background:#3b82f6; color:white; border:none; cursor:pointer; }
        .archive-clear-btn { padding:8px 10px; border-radius:6px; background:#e5e7eb; color:#374151; border:none; cursor:pointer; }
        .search-result-meta { font-size:0.85rem; color:#6b7280; }

        @media (max-width: 768px) {
            .sections-wrapper { padding-bottom:88px; }
            .task-card-wrapper {
                space-y: 0.5rem; 
            }
            .task-card {
                border-radius: 0;
            }
            .task-card.completed {
                background-color: #e5e7eb; 
            }
            
            .archive-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .archive-table-wrapper > table {
                min-width: 640px; 
            }
            .archive-table-wrapper td, .archive-table-wrapper th {
                white-space: nowrap; 
            }
            .archive-table-wrapper .task-memo-cell {
                white-space: normal;
                min-width: 250px;
            }
        }
		
    </style>
</head>
<body class="antialiased text-gray-800">

<div class="header">
    <div class="container mx-auto max-w-7xl">
        <header class="mobile-compact-header bg-white p-4 py-1 flex flex-col md:flex-row justify-between items-center header-content">
            <div class="flex-1">
                <h1 class="text-xl font-bold text-gray-700">DailyTaskList</h1>
                <p id="current-date" class="text-sm text-gray-500"></p>
            </div>
            <div class="mt-2 md:mt-0 text-center md:text-right header-stats">
                <p class="text-gray-600">全体の終了予測</p>
                <p id="total-estimated-end-time" class="text-2xl font-semibold text-blue-600">--:--</p>
            </div>
        </header>

        <nav id="main-tabs" class="mobile-nav flex space-x-0 border-b-2 border-gray-200 overflow-x-auto">
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="today">当日のタスク</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="repeat">リピートタスク</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="projects">プロジェクト</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="archive">アーカイブ</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="data">データ管理</button>
        </nav>
    </div>
</div>

<div class="container mx-auto p-4 max-w-7xl">

    <main>
        <div id="today" class="tab-content space-y-4">
             <div class="flex justify-between items-center">
                 <div id="today-date-nav" class="flex items-center gap-2">
                    <button id="prev-day-btn" class="p-2 rounded-md bg-white hover:bg-gray-100 shadow-sm">&lt;</button>
                    <h2 id="view-date-display" class="font-bold text-lg"></h2>
                    <button id="next-day-btn" class="p-2 rounded-md bg-white hover:bg-gray-100 shadow-sm">&gt;</button>
                 </div>
                <p class="text-sm text-gray-500 hidden md:block">キーボード: [↑][↓]選択, [Space]開始/停止, [P]先送り, [Ctrl+↑][↓]移動, [N]新規, [E]編集, [M]メモ, [D]削除</p>
            </div>
            <div id="sections-container" class="sections-wrapper"></div>
        </div>

        <div id="repeat" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">リピートタスク管理</h2>
                <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4 items-end">
                    <input type="text" id="repeat-task-name" placeholder="タスク名" class="md:col-span-2 p-2 border rounded-lg">
                    <div class="grid grid-cols-2 gap-4">
                        <input type="number" id="repeat-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                        <select id="repeat-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
                    </div>
                    <select id="repeat-task-type" class="p-2 border rounded-lg bg-white md:col-span-2">
                        <option value="daily">毎日</option>
                        <option value="weekly">毎週</option>
                        <option value="monthly">毎月</option>
                        <option value="interval">○日ごと</option>
                    </select>
                </div>

                <div class="mb-4">
                    <textarea id="repeat-task-memo" placeholder="メモ (任意)" class="w-full p-2 border rounded-lg h-20"></textarea>
                </div>

                <div id="repeat-weekly-options" class="hidden flex flex-wrap gap-x-4 gap-y-2 mb-4 p-3 bg-gray-50 rounded-lg"></div>
                <div id="repeat-monthly-options" class="hidden mb-4 p-3 bg-gray-50 rounded-lg">
                    <label class="text-sm">日付: <input type="number" id="repeat-monthly-day" placeholder="1～31" class="p-2 border rounded-lg w-24" min="1" max="31"></label>
                </div>
                <div id="repeat-interval-options" class="hidden mb-4 p-3 bg-gray-50 rounded-lg space-y-2 md:space-y-0 md:items-center md:space-x-4">
                    <label class="text-sm">何日ごと: <input type="number" id="repeat-interval-days" placeholder="例: 3" class="p-2 border rounded-lg w-24" min="1"></label>
                    <label class="text-sm">基準日: <input type="date" id="repeat-interval-start-date" class="p-2 border rounded-lg"></label>
                </div>

                <div class="flex gap-3">
                    <button id="add-repeat-task-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ リピートタスクを追加</button>
                    <button id="generate-from-repeat-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">▶ 今日のタスクを生成</button>
                </div>

                <div id="repeat-tasks-container" class="mt-6"></div>
            </div>
        </div>

        <div id="projects" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">プロジェクト管理</h2>
                <div class="flex flex-wrap gap-4 items-center mb-4">
                    <input type="text" id="project-name" placeholder="プロジェクト名" class="flex-grow p-2 border rounded-lg">
                    <input type="color" id="project-color" value="#4a90e2" class="p-1 h-10 w-12 border rounded-lg">
                    <button id="add-project-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ プロジェクトを追加</button>
                </div>
                <div id="projects-container" class="mt-6"></div>
            </div>
        </div>
        
        <div id="archive" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <div id="archive-tabs-container" class="archive-tabs flex mb-4">
                    <div class="archive-tab active" data-view="date">日付</div>
                    <div class="archive-tab" data-view="project">プロジェクト</div>
					<div class="archive-tab" data-view="search">検索</div>
                </div>
                
                <div id="archive-date-view">
                    <div class="flex justify-between items-center mb-4">
                        <button id="prev-archive-day" class="p-2 rounded-md bg-gray-200 hover:bg-gray-300">&lt;</button>
                        <h2 id="archive-date" class="font-bold"></h2>
                        <button id="next-archive-day" class="p-2 rounded-md bg-gray-200 hover:bg-gray-300">&gt;</button>
                    </div>
                    <div id="archive-tasks-list"></div>
                </div>

                <div id="archive-project-view" class="hidden">
                    <div class="mb-4">
                        <select id="archive-project-select" class="p-2 border rounded-lg bg-white">
                            <option value="">プロジェクトを選択</option>
                        </select>
                    </div>
                    <div id="archive-project-tasks"></div>
                </div>

				<div id="archive-search-view" class="hidden">
    				<div class="archive-search-box">
        				<input id="archive-search-input" class="archive-search-input" type="text" placeholder="タスク名またはメモを検索">
        				<button id="archive-search-btn" class="archive-search-btn">検索</button>
        				<button id="archive-clear-btn" class="archive-clear-btn">クリア</button>
    				</div>
    				<div id="archive-search-results"></div>
				</div>
				
            </div>
        </div>

        <div id="data" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">データ管理</h2>
                <div class="space-y-6">
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">Google Drive</h3>
                        <p class="text-sm text-gray-600 mb-3">タスクデータをGoogle Driveに保存し、他のデバイスと同期します(管理者専用)</p>
                        <div id="auth-container">
                            <button id="authorize_button" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg" disabled>API Loading...</button>
                        </div>
                        <div id="signout_container" class="hidden">
                            <p id="auth-status" class="text-sm text-green-600 mb-2"></p>
                            <button id="signout_button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">ログアウト</button>
                        </div>
                        <p id="drive-status" class="text-sm text-gray-500 mt-2"></p>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">データエクスポート</h3>
                        <p class="text-sm text-gray-600 mb-3">現在のデータをJSONファイルとしてダウンロードします。</p>
                        <button id="export-data-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">データをエクスポート</button>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">データインポート</h3>
                        <p class="text-sm text-gray-600 mb-3">JSONファイルからデータを復元します。IDが重複するデータは上書きされ、存在しないデータは追加されます。</p>
                        <input type="file" id="import-file" accept=".json" class="mb-3 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                        <button id="import-data-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">データをインポート</button>
                    </div>
                    <div class="border p-4 rounded-lg border-red-200">
                        <h3 class="text-lg font-semibold mb-3 text-red-700">データ削除</h3>
                        <p class="text-sm text-gray-600 mb-3">全てのデータを削除します。この操作は元に戻せません。</p>
                        <button id="clear-data-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">全データを削除</button>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>

<button id="add-task-fab" class="add-task-fab bg-blue-600 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center text-2xl">＋</button>

<button id="sync-data-fab" class="sync-data-fab bg-green-600 hover:bg-green-700 text-white w-14 h-14 rounded-full shadow-lg items-center justify-center">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
    </svg>
</button>


<div id="add-task-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">タスクを追加</h3>
        <div class="space-y-4">
            <input type="text" id="new-task-name" placeholder="タスク名" class="w-full p-2 border rounded-lg">
            <input type="number" id="new-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg" value="5">
            <select id="new-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
        </div>
        <div class="flex gap-3 mt-6">
            <button id="save-new-task-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">追加</button>
            <button id="cancel-add-task-btn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>


<div id="task-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">タスクを編集</h3>
        <div class="space-y-4">
            <input type="text" id="edit-task-name" placeholder="タスク名" class="w-full p-2 border rounded-lg">
            <div class="grid grid-cols-2 gap-4">
                 <input type="number" id="edit-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                 <select id="edit-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
            </div>
            <textarea id="edit-task-memo" placeholder="メモ" class="w-full p-2 border rounded-lg h-20"></textarea>
            <div class="grid grid-cols-2 gap-4">
                 <div>
                    <label for="edit-task-startTime" class="text-sm font-medium text-gray-700">開始時刻</label>
                    <input type="time" id="edit-task-startTime" class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label for="edit-task-endTime" class="text-sm font-medium text-gray-700">終了時刻</label>
                    <input type="time" id="edit-task-endTime" class="w-full p-2 border rounded-lg">
                </div>
            </div>
        </div>
        <div class="flex gap-3 mt-6">
            <button id="save-task-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-task-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
            <button id="create-repeat-from-task" class="flex-1 bg-green-500 hover:bg-green-600 text-white py-2 px-2 rounded-lg">リピート作成</button>
        </div>
    </div>
</div>

<div id="memo-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">メモを編集</h3>
        <textarea id="edit-memo-text" placeholder="メモを入力..." class="w-full p-2 border rounded-lg h-32"></textarea>
        <div class="flex gap-3 mt-6">
            <button id="save-memo-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-memo-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="repeat-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-lg">
        <h3 class="text-lg font-bold mb-4">リピートタスクを編集</h3>
        <div class="space-y-4">
            <input type="text" id="edit-repeat-name" placeholder="タスク名" class="w-full p-2 border rounded-lg">
             <div class="grid grid-cols-2 gap-4">
                <input type="number" id="edit-repeat-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                <select id="edit-repeat-project" class="w-full p-2 border rounded-lg bg-white"></select>
            </div>
            <textarea id="edit-repeat-memo" placeholder="メモ" class="w-full p-2 border rounded-lg h-20"></textarea>
            <select id="edit-repeat-type" class="w-full p-2 border rounded-lg bg-white">
                <option value="daily">毎日</option>
                <option value="weekly">毎週</option>
                <option value="monthly">毎月</option>
                <option value="interval">○日ごと</option>
            </select>
        </div>

        <div id="edit-repeat-weekly-options" class="hidden flex flex-wrap gap-x-4 gap-y-2 mt-4 p-3 bg-gray-50 rounded-lg"></div>
        <div id="edit-repeat-monthly-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg">
            <label class="text-sm">日付: <input type="number" id="edit-repeat-monthly-day" placeholder="1～31" class="p-2 border rounded-lg w-24" min="1" max="31"></label>
        </div>
        <div id="edit-repeat-interval-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg space-y-2 md:space-y-0 md:items-center md:space-x-4">
            <label class="text-sm">何日ごと: <input type="number" id="edit-repeat-interval-days" placeholder="例: 3" class="p-2 border rounded-lg w-24" min="1"></label>
            <label class="text-sm">基準日: <input type="date" id="edit-repeat-interval-start-date" class="p-2 border rounded-lg"></label>
        </div>

        <div class="flex gap-3 mt-6">
            <button id="save-repeat-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-repeat-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Helper Functions ---
        const el = (id) => document.getElementById(id);
        const q = (selector) => document.querySelector(selector);
        const qa = (selector) => document.querySelectorAll(selector);

        // --- GOOGLE DRIVE SYNC START ---
        const dailyTaskListApp = window.dailyTaskListApp = {
            driveFileId: null,
            saveTimeout: null,
            tokenClient: null,
            authorizeButton: el('authorize_button'),
            signoutButton: el('signout_button'),
            authContainer: el('auth-container'),
            signoutContainer: el('signout_container'),
            authStatusEl: el('auth-status'),
            driveStatusEl: el('drive-status'),
            syncDataFab: el('sync-data-fab'),

            updateAuthUi: function(isLoggedIn) {
                this.authContainer.classList.toggle('hidden', isLoggedIn);
                this.signoutContainer.classList.toggle('hidden', !isLoggedIn);
                
                if (isLoggedIn) {
                    this.authStatusEl.textContent = 'Googleアカウントにログイン済みです。';
                    this.syncDataFab.style.display = 'flex';
                } else {
                    this.authorizeButton.disabled = false;
                    this.authorizeButton.textContent = 'Google ログイン';
                    this.driveStatusEl.textContent = 'ログインするとデータを同期できます。';
                    this.syncDataFab.style.display = 'none';
                }
            },

            findDriveFile: async function() {
                this.driveStatusEl.textContent = 'Driveファイルを検索中...';
                try {
                    const response = await gapi.client.drive.files.list({
                        spaces: 'appDataFolder',
                        fields: 'files(id, name)',
                        q: `name='DailyTaskListData.json'`
                    });
                    if (response.result.files && response.result.files.length > 0) {
                        this.driveFileId = response.result.files[0].id;
                        this.driveStatusEl.textContent = 'データファイルが見つかりました。';
                        return this.driveFileId;
                    } else {
                        this.driveFileId = null;
                        this.driveStatusEl.textContent = 'データファイルが見つかりません。初回保存時に作成されます。';
                        return null;
                    }
                } catch (err) {
                    console.error('Error finding file:', err);
                    this.driveStatusEl.textContent = `エラー: ${err.result?.error?.message || 'Unknown error'}`;
                    return null;
                }
            },

            loadStateFromDrive: async function() {
                if (!gapi.client.getToken()) {
                    alert('Googleアカウントにログインしてください。');
                    return;
                }
                
                await this.findDriveFile();
                if (!this.driveFileId) {
                    this.driveStatusEl.textContent = '初回同期を開始します...';
                    await this.saveStateToDrive();
                    return;
                };

                this.driveStatusEl.textContent = 'Driveからデータを読み込み中...';
                try {
                    const response = await gapi.client.drive.files.get({
                        fileId: this.driveFileId,
                        alt: 'media'
                    });

                    const importedData = response.result;
                    
                    const driveDailyTasks = importedData.dailyTasks || {};
                    const localDailyTasks = state.dailyTasks;
                    const allDailyDates = new Set([...Object.keys(localDailyTasks), ...Object.keys(driveDailyTasks)]);

                    allDailyDates.forEach(date => {
                        const localTasksForDate = localDailyTasks[date] || [];
                        const driveTasksForDate = driveDailyTasks[date] || [];
                        const combinedTasks = [...localTasksForDate, ...driveTasksForDate];
                        const taskMap = new Map();

                        for (const task of combinedTasks) {
                            const key = task.originRepeatId ? `repeat-${date}-${task.originRepeatId}` : `task-${task.id}`;
                            if (taskMap.has(key)) {
                                const existingTask = taskMap.get(key);
                                const getTaskPriority = (t) => {
                                    if (getTaskStatus(t) === 'completed') return 2;
                                    if (getTaskStatus(t) === 'running') return 1;
                                    return 0;
                                };
                                if (getTaskPriority(task) >= getTaskPriority(existingTask)) {
                                    taskMap.set(key, task);
                                }
                            } else {
                                taskMap.set(key, task);
                            }
                        }
                        state.dailyTasks[date] = Array.from(taskMap.values());
                    });

                    const driveArchivedTasks = importedData.archivedTasks || {};
                    const localArchivedTasks = state.archivedTasks;
                    const allArchiveDates = new Set([...Object.keys(localArchivedTasks), ...Object.keys(driveArchivedTasks)]);

                    allArchiveDates.forEach(date => {
                        const localTasks = localArchivedTasks[date] || [];
                        const driveTasks = driveArchivedTasks[date] || [];
                        const taskMap = new Map();
                        
                        for (const task of [...localTasks, ...driveTasks]) {
                            taskMap.set(task.id, task);
                        }
                        state.archivedTasks[date] = Array.from(taskMap.values());
                    });

                    if (importedData.projects) state.projects = importedData.projects;
                    if (importedData.repeatTasks) state.repeatTasks = importedData.repeatTasks;
                    state.lastDate = importedData.lastDate || state.lastDate;
                    
                    stopActiveTimer();
                    state.viewDate = getFormattedDate(new Date());
                    const tasksToday = getTasksForViewDate();
                    state.focusedTaskId = tasksToday.length > 0 ? tasksToday[0].id : null;
                    
                    Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
                    
                    saveState(); 
                    render();
                    this.driveStatusEl.textContent = `Driveからデータを読み込みました (${new Date().toLocaleTimeString()})。`;
                    alert('Driveからデータを読み込み、重複タスクを解決しました。');

                } catch (err) {
                    console.error('Error loading state from Drive:', err);
                    this.driveStatusEl.textContent = `読み込みエラー: ${err.result?.error?.message || 'Unknown error'}`;
                }
            },
            
            saveStateToDrive: async function() {
                if (!gapi.client.getToken()) return;
                
                this.driveStatusEl.textContent = 'Driveへ保存準備中...';

                const dataToSave = {
                    dailyTasks: state.dailyTasks,
                    projects: state.projects,
                    repeatTasks: state.repeatTasks,
                    archivedTasks: state.archivedTasks,
                    lastDate: state.lastDate,
                    updatedAt: new Date().toISOString()
                };

                const boundary = '-------314159265358979323846';
                const delimiter = "\r\n--" + boundary + "\r\n";
                const close_delim = "\r\n--" + boundary + "--";
                const metadata = { 'name': 'DailyTaskListData.json', 'mimeType': 'application/json' };
                const fileContent = JSON.stringify(dataToSave);

                let multipartRequestBody;
                if(this.driveFileId) {
                    multipartRequestBody =
                        delimiter +
                        'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
                        JSON.stringify({}) + 
                        delimiter +
                        'Content-Type: application/json\r\n\r\n' +
                        fileContent +
                        close_delim;
                } else {
                    metadata.parents = ['appDataFolder'];
                    multipartRequestBody =
                        delimiter +
                        'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
                        JSON.stringify(metadata) +
                        delimiter +
                        'Content-Type: application/json\r\n\r\n' +
                        fileContent +
                        close_delim;
                }

                const path = this.driveFileId 
                    ? `/upload/drive/v3/files/${this.driveFileId}?uploadType=multipart` 
                    : '/upload/drive/v3/files?uploadType=multipart';
                const method = this.driveFileId ? 'PATCH' : 'POST';
                
                this.driveStatusEl.textContent = 'Driveへ保存中...';
                try {
                    const response = await gapi.client.request({
                        'path': path,
                        'method': method,
                        'headers': { 'Content-Type': 'multipart/related; boundary="' + boundary + '"' },
                        'body': multipartRequestBody
                    });

                    if (!this.driveFileId) this.driveFileId = response.result.id;
                    
                    this.driveStatusEl.textContent = `Driveに保存しました (${new Date().toLocaleTimeString()})。`;
                } catch (err) {
                    console.error('Error saving state to Drive:', err);
                    this.driveStatusEl.textContent = `保存エラー: ${err.result?.error?.message || 'Unknown error'}`;
                    if (err.result && (err.result.error.code === 404 || err.result.error.code === 401)) {
                        this.driveFileId = null; 
                        if (err.result.error.code === 401) {
                           this.updateAuthUi(false);
                           this.driveStatusEl.textContent = '認証が切れました。再ログインしてください。';
                        } else {
                           this.saveStateToDrive(); 
                        }
                    }
                }
            }
        };

        function loadGoogleApiScripts() {
            return new Promise((resolve, reject) => {
                const scriptGapi = document.createElement('script');
                scriptGapi.src = 'https://apis.google.com/js/api.js';
                scriptGapi.async = true;
                scriptGapi.defer = true;
                scriptGapi.onload = () => {
                    const scriptGis = document.createElement('script');
                    scriptGis.src = 'https://accounts.google.com/gsi/client';
                    scriptGis.async = true;
                    scriptGis.defer = true;
                    scriptGis.onload = resolve;
                    scriptGis.onerror = () => reject(new Error('Failed to load Google Identity Services script.'));
                    document.head.appendChild(scriptGis);
                };
                scriptGapi.onerror = () => reject(new Error('Failed to load Google API script.'));
                document.head.appendChild(scriptGapi);
            });
        }

		async function initializeGoogleSync() {
            try {
                await loadGoogleApiScripts();
                await new Promise((resolve, reject) => {
                    gapi.load('client', () => gapi.client.init({
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
                    }).then(resolve, reject));
                });

                dailyTaskListApp.tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: '134193775188-svab18grq6f1g3vt3fk0oaqdvknha5ru.apps.googleusercontent.com',
                    scope: 'https://www.googleapis.com/auth/drive.appdata',
                    callback: (tokenResponse) => {
                        if (tokenResponse && tokenResponse.access_token) {
                            gapi.client.setToken(tokenResponse);
                            dailyTaskListApp.updateAuthUi(true);
                            dailyTaskListApp.loadStateFromDrive();
                        } else {
                            console.error('Auth failed: No access token', tokenResponse);
                             dailyTaskListApp.updateAuthUi(false);
                        }
                    },
                     error_callback: (error) => {
                        console.warn('Token client error:', error);
                        dailyTaskListApp.updateAuthUi(false);
                    }
                });
                dailyTaskListApp.updateAuthUi(false);
            } catch (error) {
                console.error('Failed to initialize Google Sync:', error);
                dailyTaskListApp.authorizeButton.textContent = 'API Error';
                dailyTaskListApp.authorizeButton.disabled = true;
                dailyTaskListApp.driveStatusEl.textContent = 'Google APIの読み込みに失敗しました。';
            }
        }
        // --- GOOGLE DRIVE SYNC END ---


        // State
        const state = {
            dailyTasks: {}, 
            projects: [],
            repeatTasks: [],
            archivedTasks: {},
            viewDate: null, 
            lastDate: null,
            archiveViewDate: null,
            archiveView: 'date',
            selectedArchiveProject: '',
            settings: { dayChangeHour: 4 },
            activeTimerId: null,
            activeTaskId: null,
            focusedTaskId: null,
            editingTaskId: null,
            editingTaskDateKey: null, 
            editingRepeatId: null,
            editingMemoTaskId: null
        };

        // DOM refs
        const currentDateEl = el('current-date');
        const totalEstimatedEndTimeEl = el('total-estimated-end-time');

        // Init
        function init() {
            state.viewDate = getFormattedDate(new Date());
            loadState();
            setupEventListeners();
            initializeGoogleSync();
            checkDayChange();
            setInterval(checkDayChange, 1000 * 60); 
            updateTitle();
            
            render();
            updateTimeDisplays();
            setInterval(updateTimeDisplays, 1000*30);
            
            window.addEventListener('resize', () => {
                const activeTab = q('.tab-link.active').dataset.tab;
                if (['today', 'repeat', 'projects', 'archive'].includes(activeTab)) {
                    render();
                }
            });
        }

    function getTasksForViewDate() { return state.dailyTasks[state.viewDate] || []; }
    function setTasksForViewDate(tasks) { state.dailyTasks[state.viewDate] = tasks; }
	function updateTitle() {
        const activeTask = getTasksForViewDate().find(t => t.id === state.activeTaskId);
        document.title = activeTask ? `⏱ ${activeTask.name} - DTL` : 'DailyTaskList';
    }
    function isMobile() { return window.innerWidth <= 768; }
    function getFormattedDate(date) {
        return new Date(date.getTime() - (state.settings.dayChangeHour * 60 * 60 * 1000))
            .toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' })
            .replace(/\//g, '-');
    }

    function getTaskStatus(task) {
        if (task.startTime && task.endTime) return 'completed';
        if (task.startTime && !task.endTime) return 'running';
        return 'pending';
    }

    function updateTaskStatus(task) {
        const oldStatus = task.status;
        task.status = getTaskStatus(task);
        if (oldStatus !== 'completed' && task.status === 'completed') moveTaskToCompletedSection(task.id);
        else if (oldStatus !== 'running' && task.status === 'running') moveRunningTaskIntoPosition(task.id);
    }

    function moveTaskToCompletedSection(taskId) {
        const tasks = getTasksForViewDate();
        const taskIndex = tasks.findIndex(t => t.id === taskId);
        if (taskIndex === -1) return;
        const [task] = tasks.splice(taskIndex, 1);
        const lastCompletedIndex = tasks.map(t => t.status === 'completed').lastIndexOf(true);
        tasks.splice(lastCompletedIndex === -1 ? 0 : lastCompletedIndex + 1, 0, task);
        setTasksForViewDate(tasks);
    }

	function moveRunningTaskIntoPosition(taskId) {
	    const tasks = getTasksForViewDate();
	    const taskIndex = tasks.findIndex(t => t.id === taskId);
	    if (taskIndex === -1) return;
        const [movedTask] = tasks.splice(taskIndex, 1);
        
        // Find the index of the last completed task.
        const lastCompletedIndex = tasks.map(t => t.status === 'completed').lastIndexOf(true);
        
        // The new task should be inserted right after the last completed task.
        // If no tasks are completed, lastCompletedIndex is -1, so insertIndex becomes 0 (the top).
        const insertIndex = lastCompletedIndex + 1;

        tasks.splice(insertIndex, 0, movedTask);
        setTasksForViewDate(tasks);
	}

    function positionTooltip(tooltipContainer) {
        const tooltip = tooltipContainer.querySelector('.custom-tooltip');
        if (tooltipContainer.getBoundingClientRect().top - tooltip.getBoundingClientRect().height < 10) {
            tooltip.classList.add('tooltip-bottom');
            tooltip.classList.remove('tooltip-top');
        } else {
            tooltip.classList.add('tooltip-top');
            tooltip.classList.remove('tooltip-bottom');
        }
    }

    function loadState() {
        const defaults = {
            dailyTasks: {},
            projects: [
                { id: 'p' + Date.now(), name: '仕事', color: '#4a90e2' },
                { id: 'p' + (Date.now()+1), name: '学習', color: '#50e3c2' },
                { id: 'p' + (Date.now()+2), name: 'プライベート', color: '#f5a623' },
            ],
            repeatTasks: [],
            archivedTasks: {},
            lastDate: getFormattedDate(new Date()),
        };

        const oldTasks = localStorage.getItem('dtl_tasks');
        if (oldTasks && !localStorage.getItem('dtl_dailyTasks')) {
            const parsedOldTasks = JSON.parse(oldTasks);
            if (Array.isArray(parsedOldTasks) && parsedOldTasks.length > 0) {
                state.dailyTasks[getFormattedDate(new Date())] = parsedOldTasks;
                localStorage.removeItem('dtl_tasks');
            }
        }
        
        Object.keys(defaults).forEach(k => {
            const saved = localStorage.getItem(`dtl_${k}`);
            state[k] = saved ? JSON.parse(saved) : defaults[k];
        });
        
        Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
    }

    function saveState() {
        Object.keys(state).forEach(k => {
            if (k !== 'settings' && k !== 'archiveView' && k !== 'selectedArchiveProject') {
                localStorage.setItem(`dtl_${k}`, JSON.stringify(state[k]));
            }
        });
        
        const app = window.dailyTaskListApp;
        if (gapi?.client?.getToken()) {
            if (app.saveTimeout) clearTimeout(app.saveTimeout);
            app.saveTimeout = setTimeout(() => app.saveStateToDrive(), 2000);
        }
    }
    
    function checkDayChange() {
        const today = getFormattedDate(new Date());
        if (state.lastDate === today) return;

        console.log(`Date changed: ${state.lastDate} -> ${today}`);
        const yesterdaysTasks = state.dailyTasks[state.lastDate];
        if (yesterdaysTasks?.length > 0) {
            const leftoverTasks = yesterdaysTasks.filter(t => t.status !== 'completed');
            if (leftoverTasks.length > 0) {
                state.dailyTasks[today] = [...leftoverTasks, ...(state.dailyTasks[today] || [])];
                state.dailyTasks[state.lastDate] = yesterdaysTasks.filter(t => t.status === 'completed');
            }
        }
        
        archiveCompletedTasks(state.lastDate);
        generateTasksFromRepeatAuto(today);
        state.lastDate = today;
        state.viewDate = today; 
        state.focusedTaskId = (state.dailyTasks[today]?.[0]?.id) || null;
        saveAndRender();
    }

    function archiveCompletedTasks(dateKey) {
        if (!state.dailyTasks[dateKey]) return;
        const completedTasks = state.dailyTasks[dateKey].filter(t => t.status === 'completed');
        if (completedTasks.length > 0) {
            state.archivedTasks[dateKey] = [...(state.archivedTasks[dateKey] || []), ...completedTasks];
            state.dailyTasks[dateKey] = state.dailyTasks[dateKey].filter(t => t.status !== 'completed');
        }
    }

    function generateTasksFromRepeatAuto(dateStr) {
        const today = new Date(dateStr);
        today.setMinutes(today.getMinutes() + today.getTimezoneOffset());
        
        const dayOfWeek = today.getDay();
        const dayOfMonth = today.getDate();
        state.dailyTasks[dateStr] = state.dailyTasks[dateStr] || [];

        state.repeatTasks.forEach(rt => {
            let shouldAdd = false;
            if (rt.type === 'daily') shouldAdd = true;
            else if (rt.type === 'weekly' && rt.value?.includes(dayOfWeek)) shouldAdd = true;
            else if (rt.type === 'monthly' && rt.value == dayOfMonth) shouldAdd = true;
            else if (rt.type === 'interval' && rt.startDate && rt.value > 0) {
                const start = new Date(rt.startDate);
                start.setMinutes(start.getMinutes() + start.getTimezoneOffset());
                const diffDays = Math.floor((today - start) / (1000 * 60 * 60 * 24));
                if (diffDays >= 0 && diffDays % rt.value === 0) shouldAdd = true;
            }

            if (shouldAdd && !state.dailyTasks[dateStr].some(task => task.originRepeatId === rt.id)) {
                state.dailyTasks[dateStr].push({
                    id: 't' + Date.now() + Math.random(),
                    name: rt.name, projectId: rt.projectId || null,
                    estimatedTime: rt.estimatedTime || 0, actualTime: 0,
                    status: 'pending', isInterrupt: false, memo: rt.memo || '',
                    originRepeatId: rt.id, createdDate: dateStr,
                    startTime: null, endTime: null,
                });
            }
        });
    }

    function generateTasksFromRepeatManual() {
        const todayStr = getFormattedDate(new Date());
        const tasksBefore = (state.dailyTasks[todayStr] || []).length;
        generateTasksFromRepeatAuto(todayStr);
        const addedCount = (state.dailyTasks[todayStr] || []).length - tasksBefore;

        if (addedCount > 0) {
            const tasksForToday = getTasksForViewDate();
            state.focusedTaskId = tasksForToday.length > 0 ? tasksForToday[tasksForToday.length-1].id : null;
            saveAndRender();
            alert(addedCount + ' 件のタスクを生成しました。');
        } else {
            alert('今日生成できるリピートタスクはありません（既に生成済みか該当なし）。');
        }
    }

    function generateSingleRepeatTask(repeatTaskId) {
        const rt = state.repeatTasks.find(t => t.id === repeatTaskId);
        if (!rt) return;

        const today = getFormattedDate(new Date());
        state.dailyTasks[today] = state.dailyTasks[today] || [];
        
        if (state.dailyTasks[today].some(t => t.originRepeatId === repeatTaskId)) {
            alert('このリピートタスクは既に今日のタスクとして存在します。');
            return;
        }

        const newTask = {
            id: 't' + Date.now() + Math.random(),
            name: rt.name, projectId: rt.projectId || null,
            estimatedTime: rt.estimatedTime || 0, actualTime: 0,
            status: 'pending', isInterrupt: false, memo: rt.memo || '',
            originRepeatId: rt.id, createdDate: today,
            startTime: null, endTime: null,
        };

        const tasksForToday = getTasksForViewDate();
        const lastUncompletedIndex = Math.max(tasksForToday.map(t => t.status).lastIndexOf('pending'), tasksForToday.map(t => t.status).lastIndexOf('running'));
        tasksForToday.splice(lastUncompletedIndex !== -1 ? lastUncompletedIndex + 1 : tasksForToday.length, 0, newTask);
        
        state.focusedTaskId = newTask.id;
        state.viewDate = today;
        saveAndRender();
        alert('今日のタスクとして追加しました。');
    }
    
    // --- HTML Generation Helpers ---
    function createTaskActionButtons(isMobile) {
        const iconClass = isMobile ? "h-5 w-5" : "h-4 w-4";
        return `
            <button class="edit-task-btn text-gray-400 hover:text-blue-500 p-1" title="編集 (E)"><svg class="${iconClass}" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
            <button class="postpone-task-btn text-gray-400 hover:text-yellow-500 p-1" title="翌日に先送り (P)"><svg class="${iconClass}" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg></button>
            <button class="delete-task-btn text-gray-400 hover:text-red-500 p-1" title="削除 (D)"><svg class="${iconClass}" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
        `;
    }

    function createRepeatTaskActionButtons() {
        return `
            <button class="generate-single-repeat-btn text-gray-400 hover:text-green-500 p-1" title="今日のタスクとして生成"><svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg></button>
            <button class="edit-repeat-task-btn text-gray-400 hover:text-blue-500 p-1"><svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
            <button class="delete-repeat-task-btn text-gray-400 hover:text-red-500 p-1"><svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg></button>
        `;
    }

    function createProjectActionButtons(isMobile) {
        const iconClass = isMobile ? "h-5 w-5" : "h-4 w-4";
        return `
            <button class="edit-project-btn text-gray-400 hover:text-blue-500 p-1"><svg class="${iconClass}" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
            <button class="delete-project-btn text-gray-400 hover:text-red-500 p-1"><svg class="${iconClass}" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg></button>
        `;
    }
    
    // --- Event Listeners Setup ---
    function setupEventListeners() {
        el('sync-data-fab').addEventListener('click', () => dailyTaskListApp.loadStateFromDrive());
        dailyTaskListApp.authorizeButton.addEventListener('click', () => dailyTaskListApp.tokenClient.requestAccessToken({ prompt: 'consent' }));
        dailyTaskListApp.signoutButton.addEventListener('click', () => {
            const token = gapi.client.getToken();
            if (token) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                dailyTaskListApp.driveFileId = null;
                dailyTaskListApp.updateAuthUi(false);
            }
        });

        el('main-tabs').addEventListener('click', (e) => {
            const tab = e.target.closest('.tab-link');
            if (!tab) return;
            qa('.tab-link').forEach(t => t.classList.remove('active'));
            qa('.tab-content').forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            el(tab.dataset.tab).classList.add('active');
            
            if (tab.dataset.tab === 'today') {
                const tasks = getTasksForViewDate();
                state.focusedTaskId = tasks.find(t => t.status !== 'completed')?.id || tasks[0]?.id || null;
            } else if (tab.dataset.tab === 'archive' && !state.archiveViewDate) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                state.archiveViewDate = getFormattedDate(yesterday);
            }
            render();
        });
        q('.tab-link[data-tab="today"]').click();

        el('add-task-fab').addEventListener('click', openAddTaskModal);
        el('add-project-btn').addEventListener('click', addProject);
        el('add-repeat-task-btn').addEventListener('click', addRepeatTask);
        el('generate-from-repeat-btn').addEventListener('click', generateTasksFromRepeatManual);
        
        el('repeat-task-type').addEventListener('change', (e) => {
            el('repeat-weekly-options').classList.toggle('hidden', e.target.value !== 'weekly');
            el('repeat-monthly-options').classList.toggle('hidden', e.target.value !== 'monthly');
            el('repeat-interval-options').classList.toggle('hidden', e.target.value !== 'interval');
            if (e.target.value === 'interval' && !el('repeat-interval-start-date').value) {
                el('repeat-interval-start-date').value = new Date().toISOString().slice(0, 10);
            }
        });
        
        el('prev-day-btn').addEventListener('click', () => moveViewDate(-1));
        el('next-day-btn').addEventListener('click', () => moveViewDate(1));
        el('prev-archive-day').addEventListener('click', () => moveArchiveDate(-1));
        el('next-archive-day').addEventListener('click', () => moveArchiveDate(1));

        el('archive-tabs-container').addEventListener('click', (e) => {
            const tab = e.target.closest('.archive-tab');
            if (!tab) return;
            qa('.archive-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            state.archiveView = tab.dataset.view;
            renderArchive();
        });
        
        el('archive-project-select').addEventListener('change', (e) => {
            state.selectedArchiveProject = e.target.value;
            renderArchiveProjectView();
        });

		el('archive-search-btn').addEventListener('click', () => renderArchiveSearchView(el('archive-search-input').value));
		el('archive-clear-btn').addEventListener('click', () => {
            el('archive-search-input').value = '';
            renderArchiveSearchView('');
        });
		el('archive-search-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                renderArchiveSearchView(el('archive-search-input').value);
            }
        });

        el('export-data-btn').addEventListener('click', exportData);
        el('import-data-btn').addEventListener('click', importData);
        el('clear-data-btn').addEventListener('click', clearAllData);

        setupModalEvents();
        setupDelegatedEventListeners();
        document.addEventListener('keydown', handleKeyboardShortcuts);
        document.addEventListener('mouseover', (e) => {
            const tooltipContainer = e.target.closest('.tooltip-container');
            if (tooltipContainer) setTimeout(() => positionTooltip(tooltipContainer), 10);
        });
    }

    function setupDelegatedEventListeners() {
        // Event Delegation for Today's Tasks
        el('sections-container').addEventListener('click', (e) => {
            const taskElement = e.target.closest('[data-task-id]');
            if (!taskElement) return;
            const taskId = taskElement.dataset.taskId;

            if (e.target.closest('.timer-btn, .checkmark-btn')) toggleTimer(taskId);
            else if (e.target.closest('.delete-task-btn')) deleteTask(taskId);
            else if (e.target.closest('.postpone-task-btn')) postponeTask(taskId);
            else if (e.target.closest('.edit-task-btn')) openTaskEditModal(taskId);
            else if (e.target.closest('.memo-icon-clickable')) openMemoEditModal(taskId);
            else if (state.focusedTaskId !== taskId) {
                state.focusedTaskId = taskId;
                renderTodayTasks();
            }
        });

        // Event Delegation for Repeat Tasks
        el('repeat-tasks-container').addEventListener('click', (e) => {
            const repeatTaskElement = e.target.closest('[data-id]');
            if (!repeatTaskElement) return;
            const repeatId = repeatTaskElement.dataset.id;

            if (e.target.closest('.generate-single-repeat-btn')) generateSingleRepeatTask(repeatId);
            else if (e.target.closest('.edit-repeat-task-btn')) openRepeatEditModal(repeatId);
            else if (e.target.closest('.delete-repeat-task-btn')) deleteRepeatTask(repeatId);
        });
        
        // Event Delegation for Projects
        el('projects-container').addEventListener('click', (e) => {
            const projectElement = e.target.closest('[data-id]');
            if (!projectElement) return;
            const projectId = projectElement.dataset.id;

            if (e.target.closest('.edit-project-btn')) editProject(projectId);
            else if (e.target.closest('.delete-project-btn')) deleteProject(projectId);
        });
        
        // Event Delegation for Archive
        el('archive-tasks-list').addEventListener('click', (e) => {
            const taskElement = e.target.closest('[data-task-id]');
            if (!taskElement) return;
            const { taskId, dateKey } = taskElement.dataset;

            if (e.target.closest('.edit-archived-task-btn')) openArchivedTaskEditModal(dateKey, taskId);
            else if (e.target.closest('.delete-archived-task-btn')) deleteArchivedTask(dateKey, taskId);
        });
    }


    function setupModalEvents() {
        el('save-new-task-btn').addEventListener('click', () => {
             addTask(el('new-task-name').value, el('new-task-time').value, el('new-task-project').value);
            closeModal('add-task-modal');
        });
        el('cancel-add-task-btn').addEventListener('click', () => closeModal('add-task-modal'));
        
        el('save-task-edit').addEventListener('click', saveTaskEdit);
        el('cancel-task-edit').addEventListener('click', () => closeModal('task-edit-modal'));
        el('create-repeat-from-task').addEventListener('click', createRepeatFromTask);

        el('edit-memo-text').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); saveMemoEdit(); }
        });
        el('save-memo-edit').addEventListener('click', saveMemoEdit);
        el('cancel-memo-edit').addEventListener('click', () => closeModal('memo-edit-modal'));

        el('save-repeat-edit').addEventListener('click', saveRepeatEdit);
        el('cancel-repeat-edit').addEventListener('click', () => closeModal('repeat-edit-modal'));
        el('edit-repeat-type').addEventListener('change', (e) => {
            el('edit-repeat-weekly-options').classList.toggle('hidden', e.target.value !== 'weekly');
            el('edit-repeat-monthly-options').classList.toggle('hidden', e.target.value !== 'monthly');
            el('edit-repeat-interval-options').classList.toggle('hidden', e.target.value !== 'interval');
             if (e.target.value === 'interval' && !el('edit-repeat-interval-start-date').value) {
                el('edit-repeat-interval-start-date').value = new Date().toISOString().slice(0, 10);
            }
        });

        el('new-task-name').addEventListener('keydown', (e) => {
            if (e.key !== 'Enter') return;
            e.preventDefault();
            if (el('new-task-name').value.trim() === '') closeModal('add-task-modal');
            else el('save-new-task-btn').click();
        });

        el('edit-task-name').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); saveTaskEdit(); }});
        el('edit-repeat-name').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); saveRepeatEdit(); }});
        qa('.modal').forEach(modal => modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(modal.id); }));
    }

    function openModal(modalId) { el(modalId).classList.add('active'); }
    function closeModal(modalId) {
        el(modalId).classList.remove('active');
        if (modalId === 'task-edit-modal') {
            state.editingTaskDateKey = null;
            state.editingTaskId = null;
        }
    }

    function render() {
        const activeTab = q('.tab-link.active').dataset.tab;
        if (activeTab === 'today') renderTodayTasks();
        else if (activeTab === 'repeat') renderRepeatTasks();
        else if (activeTab === 'projects') renderProjects();
        else if (activeTab === 'archive') renderArchive();
        updateProjectDropdowns();
        calculateAllEstimates();
		updateTitle();
    }

    function renderTodayTasks() {
        const container = el('sections-container');
        container.innerHTML = '';
        el('view-date-display').textContent = new Date(state.viewDate).toLocaleDateString('ja-JP', { month: 'long', day: 'numeric', weekday: 'short' });
        el('prev-day-btn').style.visibility = state.viewDate <= getFormattedDate(new Date()) ? 'hidden' : 'visible';

        const tasks = getTasksForViewDate();
        if (tasks.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">タスクはありません。[N]キーで追加できます。</p>`;
            return;
        }

        if (isMobile()) renderTaskCards(container);
        else renderTaskTable(container);

        const focusedEl = q('.task-row.focused, .task-card.focused');
        if (focusedEl) focusedEl.scrollIntoView({ block:'nearest', behavior:'smooth' });
    }

    function renderTaskTable(container) {
        const tasks = getTasksForViewDate();
        const table = document.createElement('table');
        table.className = 'min-w-full task-table';
        table.innerHTML = `
            <thead class="bg-gray-50"><tr>
                <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">見積</th>
                <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-28">実績</th>
                <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">開始</th>
                <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">終了</th>
                <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-28">操作</th>
            </tr></thead>
            <tbody>${tasks.map((task, index) => renderTaskTableRow(task, index)).join('')}</tbody>`;
        
        const wrapper = document.createElement('div');
        wrapper.className = 'bg-white rounded-lg shadow-md overflow-x-auto';
        wrapper.appendChild(table);
        container.appendChild(wrapper);
        setupDragAndDrop('.task-row', tasks);
    }
    
    function renderTaskTableRow(task, index) {
        const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
        const isRunning = task.status === 'running';
        const isCompleted = task.status === 'completed';

        let timerButtonHtml = `<button class="timer-btn rounded-full transition-colors duration-200 ${isRunning ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}">${isRunning ? '■' : '▶'}</button>`;
        if (isCompleted) {
            timerButtonHtml = `<button class="timer-btn checkmark-btn rounded-full bg-gray-200 hover:bg-gray-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-600" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg></button>`;
        }
        const memoIcon = task.memo ? `<span class="tooltip-container memo-icon-clickable"><svg class="h-4 w-4 inline-block ml-1 text-gray-400 cursor-pointer hover:text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(task.memo)}</span></span>` : '';

        return `
            <tr class="border-b task-row ${isCompleted ? 'bg-gray-100 text-gray-500' : ''} ${isRunning ? 'bg-blue-50' : ''} ${task.id === state.focusedTaskId ? 'focused' : ''}" data-task-id="${task.id}" data-index="${index}" draggable="true">
                <td class="text-center"><span class="drag-handle">⋮⋮</span></td>
                <td class="text-center">${timerButtonHtml}</td>
                <td>
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-1 min-w-0">
                            <span class="inline-block w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${project.color};"></span>
                            <span class="pl-1 font-semibold truncate" title="${escapeHtml(task.name || '')}">${formatTaskName(task.name)}</span>${memoIcon}
                        </div>
                        <span class="text-xs text-gray-400 ml-2 whitespace-nowrap flex-shrink-0">${escapeHtml(project.name)}</span>
                    </div>
                </td>
                <td class="text-sm whitespace-nowrap">${task.estimatedTime || 0} 分</td>
                <td class="text-sm whitespace-nowrap"><span class="font-mono time-actual">${formatTime(calculateActualTime(task))}</span></td>
                <td class="text-sm whitespace-nowrap font-mono">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>
                <td class="text-sm whitespace-nowrap font-mono">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>
                <td class="text-center space-x-1">${createTaskActionButtons(false)}</td>
            </tr>`;
    }

    function renderTaskCards(container) {
        const tasks = getTasksForViewDate();
        const wrapper = document.createElement('div');
        wrapper.className = 'task-card-wrapper';
        wrapper.innerHTML = tasks.map((task, index) => renderTaskCard(task, index)).join('');
        container.appendChild(wrapper);
        setupDragAndDrop('.task-card', tasks);
    }
    
    function renderTaskCard(task, index) {
        const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
        const isCompleted = task.status === 'completed';
        const isRunning = task.status === 'running';

        let timerButtonHtml = `<button class="timer-btn rounded-full transition-colors duration-200 flex-shrink-0 ${isRunning ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}">${isRunning ? '■' : '▶'}</button>`;
        if (isCompleted) {
            timerButtonHtml = `<button class="timer-btn checkmark-btn rounded-full bg-gray-200 hover:bg-gray-300"><svg class="h-5 w-5 text-green-600" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg></button>`;
        }
        const memoIcon = task.memo ? `<span class="tooltip-container memo-icon-clickable"><svg class="h-4 w-4 inline-block ml-1 text-gray-400 cursor-pointer hover:text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(task.memo)}</span></span>` : '';

        return `
            <div class="task-card bg-white p-3 mt-2 shadow border-l-4 ${isCompleted ? 'completed' : ''} ${isRunning ? 'bg-blue-50' : ''} ${task.id === state.focusedTaskId ? 'focused' : ''}" style="border-left-color: ${project.color};" data-task-id="${task.id}" data-index="${index}" draggable="true">
                <div class="flex items-center gap-3">
                    <div class="flex flex-col items-center">${timerButtonHtml}<div class="drag-handle text-gray-400 hover:text-gray-600 cursor-move mt-1">⋮⋮</div></div>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-start">
                             <h3 class="font-semibold text-base truncate flex items-center pr-2" title="${escapeHtml(task.name || '')}">${formatTaskName(task.name)}${memoIcon}</h3>
                             <div class="flex space-x-1 flex-shrink-0">${createTaskActionButtons(true)}</div>
                        </div>
                        <p class="text-sm text-gray-500">${escapeHtml(project.name)}</p>
                        <div class="flex items-center justify-between text-xs text-gray-600 mt-1">
                            <span>見積: ${task.estimatedTime || 0}分</span>
                            <div class="font-mono text-gray-400">${task.startTime ? formatClockTime(new Date(task.startTime)) : ''}${task.endTime ? ' - ' + formatClockTime(new Date(task.endTime)) : ''}</div>
                        </div>
                    </div>
                </div>
            </div>`;
    }

    function renderArchive() {
        el('archive-date-view').classList.toggle('hidden', state.archiveView !== 'date');
        el('archive-project-view').classList.toggle('hidden', state.archiveView !== 'project');
        el('archive-search-view').classList.toggle('hidden', state.archiveView !== 'search');

        if (state.archiveView === 'date') renderArchiveDateView();
        else if (state.archiveView === 'project') {
            updateArchiveProjectSelect();
            renderArchiveProjectView();
        } else if (state.archiveView === 'search') renderArchiveSearchView(el('archive-search-input').value);
    }

    function renderArchiveDateView() {
        const dateObj = new Date(state.archiveViewDate);
        el('archive-date').textContent = dateObj.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
        el('next-archive-day').disabled = state.archiveViewDate === getFormattedDate(new Date());
        el('next-archive-day').classList.toggle('opacity-50', el('next-archive-day').disabled);

        const tasksForDay = state.archivedTasks[state.archiveViewDate] || [];
        if (tasksForDay.length === 0) {
            el('archive-tasks-list').innerHTML = '<p class="text-center text-gray-500 py-8">この日に完了したタスクはありません。</p>';
            return;
        }

        const tableHtml = `<div class="archive-table-wrapper"><table class="min-w-full bg-white">
            <thead class="bg-gray-50"><tr>
                <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">実績時間</th>
                <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">開始</th>
                <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">終了</th>
                <th class="py-2 px-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">操作</th>
            </tr></thead><tbody>
            ${tasksForDay.map(task => {
                const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
                const memoHtml = task.memo ? `<p class="text-xs text-gray-500 mt-1 whitespace-pre-wrap pl-4">${escapeHtml(task.memo)}</p>` : '';
                return `<tr class="border-b" data-task-id="${task.id}" data-date-key="${state.archiveViewDate}">
                    <td class="py-2 px-3 task-memo-cell">
                        <div class="flex items-center space-x-2">
                           <span class="inline-block w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${project.color};"></span>
                           <div>
                             <span class="font-semibold">${formatTaskName(task.name)}</span>
                             <span class="text-xs text-gray-400 ml-2">${escapeHtml(project.name)}</span>
                           </div>
                        </div>${memoHtml}</td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${formatTime(calculateActualTime(task))}</td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>
                    <td class="py-2 px-3 text-center space-x-1">
                        <button class="edit-archived-task-btn text-gray-400 hover:text-blue-500 p-1" title="編集"><svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>
                        <button class="delete-archived-task-btn text-gray-400 hover:text-red-500 p-1" title="削除"><svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </td></tr>`;
            }).join('')}
            </tbody></table></div>`;
        el('archive-tasks-list').innerHTML = tableHtml;
    }

    function updateArchiveProjectSelect() {
        const select = el('archive-project-select');
        select.innerHTML = '<option value="">プロジェクトを選択</option>' + state.projects.map(p => `<option value="${p.id}">${escapeHtml(p.name)}</option>`).join('');
        if (state.selectedArchiveProject) select.value = state.selectedArchiveProject;
    }

    function renderArchiveProjectView() {
        const container = el('archive-project-tasks');
        if (!state.selectedArchiveProject) {
            container.innerHTML = '<p class="text-center text-gray-500 py-8">プロジェクトを選択してください。</p>';
            return;
        }

        const selectedProject = state.projects.find(p => p.id === state.selectedArchiveProject);
        const projectTasks = Object.entries(state.archivedTasks).flatMap(([date, tasks]) => 
            tasks.filter(task => task.projectId === state.selectedArchiveProject).map(task => ({ date, ...task }))
        ).sort((a, b) => b.date.localeCompare(a.date));

        if (projectTasks.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">「${escapeHtml(selectedProject.name)}」で完了したタスクはありません。</p>`;
            return;
        }

        let currentRenderDate = '';
        container.innerHTML = projectTasks.map(({ date, ...task }) => {
            let dateHeader = '';
            if (date !== currentRenderDate) {
                currentRenderDate = date;
                const dateLabel = new Date(date).toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
                dateHeader = `<h3 class="font-bold text-lg mt-6 mb-3 pb-2 border-b" style="color: ${selectedProject.color}">${dateLabel}</h3>`;
            }
            const memoHtml = task.memo ? `<p class="text-xs text-gray-500 mt-1 whitespace-pre-wrap">${escapeHtml(task.memo)}</p>` : '';
            return `${dateHeader}<div class="bg-gray-50 p-3 rounded"><div class="flex justify-between items-start">
                    <div><span class="font-semibold">${formatTaskName(task.name)}</span>${memoHtml}</div>
                    <span class="text-sm font-mono text-gray-600">${formatTime(calculateActualTime(task))}</span>
                </div></div>`;
        }).join('');
    }

    function renderArchiveSearchView(query) {
        const container = el('archive-search-results');
        const q = (query || '').trim().toLowerCase();
        if (!q) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">検索語を入力して「検索」ボタンを押してください。</p>`;
            return;
        }

        const results = Object.entries(state.archivedTasks).flatMap(([dateKey, tasks]) =>
            tasks.filter(task => (task.name || '').toLowerCase().includes(q) || (task.memo || '').toLowerCase().includes(q))
                 .map(task => ({ date: dateKey, task }))
        ).sort((a, b) => b.date.localeCompare(a.date));

        if (results.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">「${escapeHtml(query)}」に一致するタスクは見つかりませんでした。</p>`;
            return;
        }
        
        container.innerHTML = `<div class="archive-table-wrapper"><table class="min-w-full bg-white">
            <thead class="bg-gray-50"><tr>
                <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">完了日</th>
                <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">プロジェクト</th>
                <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">実績時間</th>
            </tr></thead><tbody>
            ${results.map(({ date, task }) => {
                const project = state.projects.find(p => p.id === task.projectId) || { name: '' };
                const memoHtml = task.memo ? `<div class="text-xs text-gray-500 mt-1 whitespace-pre-wrap">${escapeHtml(task.memo)}</div>` : '';
                return `<tr class="border-b">
                    <td class="py-2 px-3 whitespace-nowrap">${new Date(date).toLocaleDateString('ja-JP', { month: '2-digit', day: '2-digit', weekday: 'short' })}</td>
                    <td class="py-2 px-3 task-memo-cell">${formatTaskName(task.name)}${memoHtml}</td>
                    <td class="py-2 px-3">${escapeHtml(project.name)}</td>
                    <td class="py-2 px-3 font-mono">${formatTime(calculateActualTime(task))}</td>
                </tr>`;
            }).join('')}
        </tbody></table></div>`;
    }

    function setupDragAndDrop(selector, list) {
        let draggedIndex = null;
        const container = q(selector).parentElement;

        container.addEventListener('dragstart', e => {
            const el = e.target.closest(selector);
            if (!el) return;
            draggedIndex = parseInt(el.dataset.index, 10);
            setTimeout(() => el.classList.add('dragging'), 0);
        });

        container.addEventListener('dragend', e => {
            const el = e.target.closest(selector);
            if (!el) return;
            el.classList.remove('dragging');
            draggedIndex = null;
            qa('.drag-over').forEach(item => item.classList.remove('drag-over'));
        });

        container.addEventListener('dragover', e => {
            e.preventDefault();
            const target = e.target.closest(selector);
            if (target && parseInt(target.dataset.index, 10) !== draggedIndex) {
                qa('.drag-over').forEach(item => item.classList.remove('drag-over'));
                target.classList.add('drag-over');
            }
        });

        container.addEventListener('dragleave', e => {
            e.target.closest(selector)?.classList.remove('drag-over');
        });

        container.addEventListener('drop', e => {
            e.preventDefault();
            const target = e.target.closest(selector);
            if (!target) return;
            target.classList.remove('drag-over');
            const toIndex = parseInt(target.dataset.index, 10);
            
            if (draggedIndex !== null && draggedIndex !== toIndex) {
                const [movedItem] = list.splice(draggedIndex, 1);
                list.splice(toIndex, 0, movedItem);
                saveAndRender();
            }
        });
    }

	function openAddTaskModal() {
	    el('new-task-name').value = '';
	    el('new-task-time').value = '5';
	    el('new-task-project').value = '';
	    openModal('add-task-modal');
		el('new-task-name').focus();
	}
    
    function openTaskEditModal(id) {
        const task = getTasksForViewDate().find(t => t.id === id);
        if (!task) return;

        state.editingTaskId = id;
        el('edit-task-name').value = task.name || '';
        el('edit-task-time').value = task.estimatedTime || 0;
        updateProjectDropdowns();
        el('edit-task-project').value = task.projectId || '';
        el('edit-task-memo').value = task.memo || '';
        el('edit-task-startTime').value = task.startTime ? new Date(task.startTime).toTimeString().slice(0, 5) : '';
        el('edit-task-endTime').value = task.endTime ? new Date(task.endTime).toTimeString().slice(0, 5) : '';
        el('create-repeat-from-task').style.display = 'block';
        openModal('task-edit-modal');
		el('edit-task-name').focus();
    }
    
    function openArchivedTaskEditModal(dateKey, taskId) {
        const task = state.archivedTasks[dateKey]?.find(t => t.id === taskId);
        if (!task) return;

        state.editingTaskId = taskId;
        state.editingTaskDateKey = dateKey; 
        el('edit-task-name').value = task.name || '';
        el('edit-task-time').value = task.estimatedTime || 0;
        updateProjectDropdowns();
        el('edit-task-project').value = task.projectId || '';
        el('edit-task-memo').value = task.memo || '';
        el('edit-task-startTime').value = task.startTime ? new Date(task.startTime).toTimeString().slice(0, 5) : '';
        el('edit-task-endTime').value = task.endTime ? new Date(task.endTime).toTimeString().slice(0, 5) : '';
        el('create-repeat-from-task').style.display = 'none';
        openModal('task-edit-modal');
		el('edit-task-name').focus();
    }

	function openMemoEditModal(id) {
	    const task = getTasksForViewDate().find(t => t.id === id);
	    if (!task) return;
	    state.editingMemoTaskId = id;
	    el('edit-memo-text').value = task.memo || '';
	    openModal('memo-edit-modal');
	    el('edit-memo-text').focus();
	}

    function saveMemoEdit() {
        const task = getTasksForViewDate().find(t => t.id === state.editingMemoTaskId);
        if (!task) return;
        task.memo = el('edit-memo-text').value.trim();
        closeModal('memo-edit-modal');
        saveAndRender();
    }

    function saveTaskEdit() {
        const tasks = state.editingTaskDateKey ? state.archivedTasks[state.editingTaskDateKey] : getTasksForViewDate();
        const task = tasks?.find(t => t.id === state.editingTaskId);
        if (!task) { closeModal('task-edit-modal'); return; }

        const name = el('edit-task-name').value.trim();
        const time = parseInt(el('edit-task-time').value, 10);

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        task.name = name;
        task.estimatedTime = time;
        task.projectId = el('edit-task-project').value || null;
        task.memo = el('edit-task-memo').value.trim();

        const startTimeValue = el('edit-task-startTime').value;
        const endTimeValue = el('edit-task-endTime').value;
        const baseDate = new Date(task.createdDate || state.editingTaskDateKey);

        task.startTime = startTimeValue ? new Date(baseDate.toDateString() + ' ' + startTimeValue).toISOString() : null;
        task.endTime = endTimeValue ? new Date(baseDate.toDateString() + ' ' + endTimeValue).toISOString() : null;
        task.actualTime = calculateActualTime(task);
        if (!state.editingTaskDateKey) updateTaskStatus(task);
        
        closeModal('task-edit-modal');
        saveAndRender();
    }

    function createRepeatFromTask() {
        const task = getTasksForViewDate().find(t => t.id === state.editingTaskId);
        if (!task) return;

        const name = el('edit-task-name').value.trim();
        const time = parseInt(el('edit-task-time').value, 10);
        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        state.repeatTasks.push({
            id: 'rt' + Date.now(),
            name: name,
            estimatedTime: time,
            projectId: el('edit-task-project').value || null,
            memo: task.memo || '',
            type: 'daily', value: null, startDate: null
        });

        closeModal('task-edit-modal');
        alert('リピートタスクを作成しました（毎日設定）。リピートタスクタブで詳細を編集できます。');
        saveAndRender();
    }

    function openRepeatEditModal(id) {
        const repeatTask = state.repeatTasks.find(rt => rt.id === id);
        if (!repeatTask) return;

        state.editingRepeatId = id;
        el('edit-repeat-name').value = repeatTask.name || '';
        el('edit-repeat-time').value = repeatTask.estimatedTime || 0;
        updateProjectDropdowns();
        el('edit-repeat-project').value = repeatTask.projectId || '';
        el('edit-repeat-memo').value = repeatTask.memo || '';
        el('edit-repeat-type').value = repeatTask.type || 'daily';

        const weeklyContainer = el('edit-repeat-weekly-options');
        if (weeklyContainer.childElementCount === 0) {
            ['日','月','火','水','木','金','土'].forEach((d, i) => {
                weeklyContainer.innerHTML += `<label class="inline-flex items-center mr-3"><input type="checkbox" value="${i}"><span class="ml-2 text-sm">${d}</span></label>`;
            });
        }

        qa('#edit-repeat-weekly-options input').forEach(cb => cb.checked = false);
        el('edit-repeat-monthly-day').value = '';
        el('edit-repeat-interval-days').value = '';
        el('edit-repeat-interval-start-date').value = '';

        if (repeatTask.type === 'weekly' && Array.isArray(repeatTask.value)) {
            qa('#edit-repeat-weekly-options input').forEach(cb => {
                cb.checked = repeatTask.value.includes(parseInt(cb.value, 10));
            });
        } else if (repeatTask.type === 'monthly') el('edit-repeat-monthly-day').value = repeatTask.value || '';
        else if (repeatTask.type === 'interval') {
            el('edit-repeat-interval-days').value = repeatTask.value || '';
            el('edit-repeat-interval-start-date').value = repeatTask.startDate || '';
        }

        el('edit-repeat-weekly-options').classList.toggle('hidden', repeatTask.type !== 'weekly');
        el('edit-repeat-monthly-options').classList.toggle('hidden', repeatTask.type !== 'monthly');
        el('edit-repeat-interval-options').classList.toggle('hidden', repeatTask.type !== 'interval');
        openModal('repeat-edit-modal');
		el('edit-repeat-name').focus();
    }

    function saveRepeatEdit() {
        const repeatTask = state.repeatTasks.find(rt => rt.id === state.editingRepeatId);
        if (!repeatTask) return;

        const name = el('edit-repeat-name').value.trim();
        const time = parseInt(el('edit-repeat-time').value, 10);
        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        const type = el('edit-repeat-type').value;
        let value = null;
        let startDate = repeatTask.startDate || null;

        if (type === 'weekly') {
            value = Array.from(qa('#edit-repeat-weekly-options input:checked')).map(cb => parseInt(cb.value, 10));
            if (value.length === 0) { alert('曜日を選択してください。'); return; }
        } else if (type === 'monthly') {
            value = parseInt(el('edit-repeat-monthly-day').value, 10);
            if (isNaN(value) || value < 1 || value > 31) { alert('有効な日付を入力してください。'); return; }
        } else if (type === 'interval') {
            value = parseInt(el('edit-repeat-interval-days').value, 10);
            if (isNaN(value) || value < 1) { alert('有効な間隔（日数）を入力してください。'); return; }
            startDate = el('edit-repeat-interval-start-date').value || new Date().toISOString().slice(0,10);
        }

        Object.assign(repeatTask, {
            name, estimatedTime: time, type, value, startDate,
            projectId: el('edit-repeat-project').value || null,
            memo: el('edit-repeat-memo').value.trim(),
        });
        
        closeModal('repeat-edit-modal');
        saveAndRender();
    }

    function renderProjects() {
        const container = el('projects-container');
        if (isMobile()) renderProjectCards(container);
        else renderProjectTable(container);
    }

    function renderProjectTable(container) {
        container.innerHTML = `<div class="overflow-x-auto"><table class="min-w-full bg-white">
            <thead class="bg-gray-100"><tr>
                <th class="py-2 px-4 border-b w-8"></th>
                <th class="py-2 px-4 border-b">プレビュー</th>
                <th class="py-2 px-4 border-b text-left">プロジェクト名</th>
                <th class="py-2 px-4 border-b">操作</th>
            </tr></thead>
            <tbody>${state.projects.map((p, idx) => `
                <tr class="border-b project-row" data-id="${p.id}" data-index="${idx}" draggable="true">
                    <td class="py-2 px-4 text-center"><span class="drag-handle">⋮⋮</span></td>
                    <td class="pt-2 px-4 text-center"><span class="inline-block w-4 h-4 rounded-full" style="background-color: ${p.color};"></span></td>
                    <td class="py-2 px-4">${escapeHtml(p.name)}</td>
                    <td class="py-2 px-4 text-center space-x-1">${createProjectActionButtons(false)}</td>
                </tr>`).join('')}
            </tbody></table></div>`;
        setupDragAndDrop('.project-row', state.projects);
    }

    function renderProjectCards(container) {
        container.innerHTML = `<div class="space-y-3">${state.projects.map((p, idx) => `
            <div class="bg-white p-3 shadow rounded-lg flex items-center gap-3 project-row" data-id="${p.id}" data-index="${idx}" draggable="true">
                <span class="drag-handle text-gray-400 hover:text-gray-600 cursor-move">⋮⋮</span>
                <span class="inline-block w-5 h-5 rounded-full flex-shrink-0" style="background-color: ${p.color};"></span>
                <span class="flex-1 font-semibold truncate">${escapeHtml(p.name)}</span>
                <div class="space-x-1">${createProjectActionButtons(true)}</div>
            </div>`).join('')}</div>`;
        setupDragAndDrop('.project-row', state.projects);
    }

    function renderRepeatTasks() {
        const container = el('repeat-tasks-container');
        const weeklyOptionsContainer = el('repeat-weekly-options');
        if (weeklyOptionsContainer.childElementCount === 0) {
            ['日','月','火','水','木','金','土'].forEach((d, i) => {
                weeklyOptionsContainer.innerHTML += `<label class="inline-flex items-center mr-3"><input type="checkbox" value="${i}"><span class="ml-2 text-sm">${d}</span></label>`;
            });
        }
        if (isMobile()) renderRepeatTaskCards(container);
        else renderRepeatTaskTable(container);
    }

    function renderRepeatTaskTable(container) {
        container.innerHTML = `<div class="overflow-x-auto"><table class="min-w-full bg-white">
            <thead class="bg-gray-100"><tr>
                <th class="py-2 px-4 border-b w-8"></th>
                <th class="py-2 px-4 border-b text-left">タスク名</th>
                <th class="py-2 px-4 border-b text-left">プロジェクト</th>
                <th class="py-2 px-4 border-b text-left">見積時間</th>
                <th class="py-2 px-4 border-b text-left">繰り返し</th>
                <th class="py-2 px-4 border-b">操作</th>
            </tr></thead><tbody>
            ${state.repeatTasks.map((rt, idx) => {
                const project = state.projects.find(p => p.id === rt.projectId) || { name: 'N/A' };
                let repeatText = '';
                if (rt.type === 'daily') repeatText = '毎日';
                else if (rt.type === 'weekly') repeatText = `毎週 ${rt.value?.map(i => '日月火水木金土'[i]).join(',') || ''}`;
                else if (rt.type === 'monthly') repeatText = `毎月 ${rt.value}日`;
                else if (rt.type === 'interval') repeatText = `${rt.value}日ごと (基準日: ${rt.startDate || '未設定'})`;
                const memoIcon = rt.memo ? `<span class="tooltip-container"><svg class="h-4 w-4 inline-block ml-1 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(rt.memo)}</span></span>` : '';
                return `<tr class="border-b repeat-task-row" data-id="${rt.id}" data-index="${idx}" draggable="true">
                    <td class="py-2 px-4 text-center"><span class="drag-handle">⋮⋮</span></td>
                    <td class="py-2 px-4"><div class="flex items-center">${formatTaskName(rt.name)}${memoIcon}</div></td>
                    <td class="py-2 px-4">${escapeHtml(project.name)}</td>
                    <td class="py-2 px-4">${rt.estimatedTime} 分</td>
                    <td class="py-2 px-4 text-sm">${escapeHtml(repeatText)}</td>
                    <td class="py-2 px-4 text-center space-x-1 whitespace-nowrap">${createRepeatTaskActionButtons()}</td>
                </tr>`;
            }).join('')}
            </tbody></table></div>`;
        setupDragAndDrop('.repeat-task-row', state.repeatTasks);
    }

    function renderRepeatTaskCards(container) {
        container.innerHTML = `<div class="space-y-3">${state.repeatTasks.map((rt, idx) => {
            const project = state.projects.find(p => p.id === rt.projectId) || { name: 'N/A', color: '#cccccc' };
            let repeatText = '';
            if (rt.type === 'daily') repeatText = '毎日';
            else if (rt.type === 'weekly') repeatText = `毎週 ${rt.value?.map(i => '日月火水木金土'[i]).join(',') || ''}`;
            else if (rt.type === 'monthly') repeatText = `毎月 ${rt.value}日`;
            else if (rt.type === 'interval') repeatText = `${rt.value}日ごと`;
            const memoIcon = rt.memo ? `<span class="tooltip-container"><svg class="h-4 w-4 inline-block ml-1 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(rt.memo)}</span></span>` : '';
            return `<div class="bg-white p-3 shadow border-l-4 repeat-task-row" style="border-left-color: ${project.color};" data-id="${rt.id}" data-index="${idx}" draggable="true">
                <div class="flex items-start gap-3">
                    <span class="drag-handle text-gray-400 hover:text-gray-600 cursor-move pt-1">⋮⋮</span>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-start">
                             <h3 class="font-semibold text-base flex items-center pr-2" title="${escapeHtml(rt.name || '')}">${formatTaskName(rt.name)} ${memoIcon}</h3>
                             <div class="flex space-x-1 flex-shrink-0">${createRepeatTaskActionButtons().replace(/h-4 w-4/g, 'h-5 w-5')}</div>
                        </div>
                        <p class="text-sm text-gray-500">${escapeHtml(project.name)}</p>
                        <div class="flex items-center justify-between text-xs text-gray-600 mt-1">
                            <span>見積: ${rt.estimatedTime || 0}分</span>
                            <span>${escapeHtml(repeatText)}</span>
                        </div>
                    </div>
                </div>
            </div>`;
        }).join('')}</div>`;
        setupDragAndDrop('.repeat-task-row', state.repeatTasks);
    }


    function updateProjectDropdowns() {
        qa('#new-task-project, #repeat-task-project, #edit-task-project, #edit-repeat-project').forEach(select => {
            const cur = select.value;
            select.innerHTML = '<option value="">プロジェクトなし</option>' + state.projects.map(p => `<option value="${p.id}">${escapeHtml(p.name)}</option>`).join('');
            select.value = cur;
        });
    }

    function addTask(name, time, projectId, isInterrupt = false, options = {}) {
        const taskName = name.trim();
        const estimatedTime = parseInt(time, 10);
        if (!taskName || isNaN(estimatedTime) || estimatedTime < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return null;
        }

        const tasks = getTasksForViewDate();
        const newTask = {
            id: 't' + Date.now() + Math.random(),
            name: taskName, projectId, estimatedTime,
            actualTime: 0, status: 'pending', isInterrupt: !!isInterrupt,
            memo: '', startTime: null, endTime: null,
            createdDate: state.viewDate, ...options
        };

        const lastUncompletedIndex = isInterrupt ? -1 : Math.max(tasks.map(t => t.status).lastIndexOf('pending'), tasks.map(t => t.status).lastIndexOf('running'));
        const insertIndex = lastUncompletedIndex !== -1 ? lastUncompletedIndex + 1 : (isInterrupt ? 0 : tasks.length);
        tasks.splice(insertIndex, 0, newTask);

        state.focusedTaskId = newTask.id;
        saveAndRender();
        return newTask;
    }

    function deleteTask(id) {
        if (!confirm('このタスクを削除しますか？')) return;
        let tasks = getTasksForViewDate();
        const idx = tasks.findIndex(t => t.id === id);
        setTasksForViewDate(tasks.filter(t => t.id !== id));
        if (state.activeTaskId === id) stopActiveTimer();
        if (state.focusedTaskId === id) {
            tasks = getTasksForViewDate(); // Re-fetch after filtering
            state.focusedTaskId = tasks[Math.min(idx, tasks.length - 1)]?.id || null;
        }
        saveAndRender();
    }
    
    function deleteArchivedTask(dateKey, taskId) {
        if (!confirm('このアーカイブ済みタスクを削除しますか？この操作は元に戻せません。')) return;
        if (state.archivedTasks[dateKey]) {
            state.archivedTasks[dateKey] = state.archivedTasks[dateKey].filter(t => t.id !== taskId);
            if (state.archivedTasks[dateKey].length === 0) delete state.archivedTasks[dateKey];
        }
        saveAndRender();
    }
    
    function postponeTask(id) {
        const tasks = getTasksForViewDate();
        const taskIndex = tasks.findIndex(t => t.id === id);
        if (taskIndex === -1) return;
        
        const [taskToMove] = tasks.splice(taskIndex, 1);
        const nextDay = new Date(state.viewDate);
        nextDay.setDate(nextDay.getDate() + 1);
        const nextDateStr = getFormattedDate(nextDay);
        state.dailyTasks[nextDateStr] = [taskToMove, ...(state.dailyTasks[nextDateStr] || [])];

        if (state.activeTaskId === id) stopActiveTimer();
        if (state.focusedTaskId === id) {
            state.focusedTaskId = tasks[Math.min(taskIndex, tasks.length - 1)]?.id || null;
        }
        saveAndRender();
    }

    function toggleTimer(id, forceStop = false) {
        const tasks = getTasksForViewDate();
        const task = tasks.find(t => t.id === id);
        if (!task) return;

        if (state.activeTaskId === id && !forceStop) {
            task.endTime = new Date().toISOString();
            updateTaskStatus(task);
            stopActiveTimer();
            state.focusedTaskId = tasks.find(t => t.status !== 'completed')?.id || null;
        } else {
            if (state.activeTaskId) {
                const runningTask = tasks.find(t => t.id === state.activeTaskId);
                if (runningTask) {
                    runningTask.endTime = new Date().toISOString();
                    updateTaskStatus(runningTask);
                }
            }
            stopActiveTimer();

            if (!forceStop) {
                if (task.startTime && task.status !== 'running') {
                    if (!confirm('このタスクは既に一度開始されています。新しいタスクとして再開しますか？')) {
                         saveAndRender(); return;
                    }
                    const newTask = addTask(task.name, task.estimatedTime, task.projectId, task.isInterrupt, {
                        memo: task.memo, originRepeatId: task.originRepeatId
                    });
                    task.endTime = task.endTime || new Date().toISOString();
                    updateTaskStatus(task);
                    toggleTimer(newTask.id);
                    return;
                }
                
                task.startTime = task.startTime || new Date().toISOString();
                task.endTime = null;
                updateTaskStatus(task);
                state.activeTaskId = id;
                state.focusedTaskId = id;
                
                state.activeTimerId = setInterval(() => {
                    const timeEl = q(`[data-task-id="${id}"] .time-actual`);
                    if (timeEl) timeEl.textContent = formatTime(calculateActualTime(task));
                }, 1000);
            }
        }
        saveAndRender();
    }

    function stopActiveTimer() {
        clearInterval(state.activeTimerId);
        state.activeTimerId = null;
        state.activeTaskId = null;
    }

    function addRepeatTask() {
        const name = el('repeat-task-name').value.trim();
        const time = parseInt(el('repeat-task-time').value, 10);
        if (!name || isNaN(time) || time < 0) return alert('タスク名と見積時間を正しく入力してください。');

        const type = el('repeat-task-type').value;
        let value, startDate = null;
        if (type === 'weekly') {
            value = Array.from(qa('#repeat-weekly-options input:checked')).map(cb => parseInt(cb.value, 10));
            if (value.length === 0) return alert('曜日を選択してください。');
        } else if (type === 'monthly') {
            value = parseInt(el('repeat-monthly-day').value, 10);
            if (isNaN(value) || value < 1 || value > 31) return alert('有効な日付を入力してください。');
        } else if (type === 'interval') {
            value = parseInt(el('repeat-interval-days').value, 10);
            if (isNaN(value) || value < 1) return alert('有効な間隔（日数）を入力してください。');
            startDate = el('repeat-interval-start-date').value || new Date().toISOString().slice(0,10);
        }

        state.repeatTasks.push({ 
            id: 'rt' + Date.now(), name, type, value, startDate,
            estimatedTime: time, 
            projectId: el('repeat-task-project').value || null,
            memo: el('repeat-task-memo').value.trim() 
        });
        
        el('repeat-task-name').value = '';
        el('repeat-task-time').value = '';
        el('repeat-task-memo').value = '';
        saveAndRender();
    }

    function deleteRepeatTask(id) {
        if (!confirm('このリピートタスクを削除しますか？')) return;
        state.repeatTasks = state.repeatTasks.filter(rt => rt.id !== id);
        saveAndRender();
    }

    function addProject() {
        const name = el('project-name').value.trim();
        if (!name) { alert('プロジェクト名を入力してください。'); return; }
        state.projects.push({ id: 'p' + Date.now(), name, color: el('project-color').value });
        el('project-name').value = '';
        saveAndRender();
    }

    function editProject(id) {
        const project = state.projects.find(p => p.id === id);
        if(!project) return;
        const newName = prompt('新しいプロジェクト名を入力してください:', project.name);
        if(newName?.trim()) project.name = newName.trim();
        const newColor = prompt('新しいカラーコード（例: #ff0000）を入力してください:', project.color);
        if(newColor && /^#[0-9A-Fa-f]{6}$/.test(newColor)) project.color = newColor;
        saveAndRender();
    }

    function deleteProject(id) {
        if (!confirm('このプロジェクトを削除しますか？')) return;
        state.projects = state.projects.filter(p => p.id !== id);
        Object.values(state.dailyTasks).flat().forEach(t => { if(t.projectId === id) t.projectId = null; });
        state.repeatTasks.forEach(rt => { if(rt.projectId === id) rt.projectId = null; });
        saveAndRender();
    }

    function exportData() {
        const dataStr = JSON.stringify({
            dailyTasks: state.dailyTasks, projects: state.projects,
            repeatTasks: state.repeatTasks, archivedTasks: state.archivedTasks,
            lastDate: state.lastDate, exportDate: new Date().toISOString()
        }, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dtl_export_${new Date().toISOString().slice(0, 10)}.json`;
        a.click();
        URL.revokeObjectURL(url);
        alert('データをエクスポートしました。');
    }

    function importData() {
        const file = el('import-file').files[0];
        if (!file || !confirm('データをインポートします。IDが重複するデータは上書きされます。よろしいですか？')) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                Object.assign(state.dailyTasks, importedData.dailyTasks || {});
                Object.assign(state.archivedTasks, importedData.archivedTasks || {});
                ['projects', 'repeatTasks'].forEach(key => {
                    if (Array.isArray(importedData[key])) {
                        const itemMap = new Map(state[key].map(item => [item.id, item]));
                        importedData[key].forEach(item => itemMap.set(item.id, item));
                        state[key] = Array.from(itemMap.values());
                    }
                });
                state.lastDate = importedData.lastDate || state.lastDate;
                stopActiveTimer();
                state.viewDate = getFormattedDate(new Date());
                const tasksToday = getTasksForViewDate();
                state.focusedTaskId = tasksToday[0]?.id || null;
                Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
                saveAndRender();
                alert('データをインポートしました。');
                el('import-file').value = '';
            } catch (error) {
                alert('無効なファイル形式です。正しいJSONファイルを選択してください。');
                console.error('Import error:', error);
            }
        };
        reader.readAsText(file);
    }

    function clearAllData() {
        if (!confirm('本当に全てのデータを削除しますか？この操作は元に戻せません。') || 
            !confirm('最終確認！全てのタスク、プロジェクト、履歴データが削除されます。')) return;
        Object.keys(localStorage).forEach(key => { if (key.startsWith('dtl_')) localStorage.removeItem(key); });
        location.reload();
    }

    function calculateAllEstimates() {
        const remainingMinutes = getTasksForViewDate()
            .filter(t => t.status !== 'completed')
            .reduce((sum, task) => sum + (task.estimatedTime || 0), 0);
        totalEstimatedEndTimeEl.textContent = remainingMinutes > 0 
            ? formatClockTime(new Date(Date.now() + remainingMinutes * 60 * 1000)) 
            : '完了';
    }

    function handleKeyboardShortcuts(e) {
        if (q('input:focus, select:focus, textarea:focus, .modal.active')) return;
        const activeTab = q('.tab-link.active').dataset.tab;
        if (activeTab === 'today') handleTodayShortcuts(e);
        else if (activeTab === 'archive' && state.archiveView === 'date') handleArchiveShortcuts(e);
    }

    function handleTodayShortcuts(e) {
        const tasks = getTasksForViewDate();
        const currentIndex = tasks.findIndex(t => t.id === state.focusedTaskId);
        const keyActionMap = {
            'n': () => openAddTaskModal(),
            'e': () => state.focusedTaskId && openTaskEditModal(state.focusedTaskId),
            'm': () => state.focusedTaskId && openMemoEditModal(state.focusedTaskId),
            'd': () => state.focusedTaskId && deleteTask(state.focusedTaskId),
            'p': () => state.focusedTaskId && postponeTask(state.focusedTaskId),
            'r': () => gapi?.client?.getToken() && dailyTaskListApp.loadStateFromDrive(),
            ' ': () => state.focusedTaskId && toggleTimer(state.focusedTaskId),
            'arrowleft': () => moveViewDate(-1),
            'arrowright': () => moveViewDate(1),
            'arrowdown': () => {
                if (e.ctrlKey || e.metaKey) {
                    if (currentIndex < tasks.length - 1) {
                        [tasks[currentIndex], tasks[currentIndex + 1]] = [tasks[currentIndex + 1], tasks[currentIndex]];
                        saveAndRender();
                    }
                } else if (currentIndex < tasks.length - 1) {
                    state.focusedTaskId = tasks[currentIndex + 1].id;
                    render();
                }
            },
            'arrowup': () => {
                if (e.ctrlKey || e.metaKey) {
                    if (currentIndex > 0) {
                        [tasks[currentIndex], tasks[currentIndex - 1]] = [tasks[currentIndex - 1], tasks[currentIndex]];
                        saveAndRender();
                    }
                } else if (currentIndex > 0) {
                    state.focusedTaskId = tasks[currentIndex - 1].id;
                    render();
                }
            },
        };
        if (keyActionMap[e.key.toLowerCase()]) {
            e.preventDefault();
            keyActionMap[e.key.toLowerCase()]();
        }
    }

    function handleArchiveShortcuts(e) {
        if (e.key === 'ArrowLeft') { e.preventDefault(); moveArchiveDate(-1); }
        if (e.key === 'ArrowRight') { e.preventDefault(); moveArchiveDate(1); }
    }
    
    function moveViewDate(direction) {
        const todayStr = getFormattedDate(new Date());
        if (direction === -1 && state.viewDate <= todayStr) return;
        const currentDate = new Date(state.viewDate);
        currentDate.setDate(currentDate.getDate() + direction);
        state.viewDate = getFormattedDate(currentDate);
        state.focusedTaskId = getTasksForViewDate()[0]?.id || null;
        renderTodayTasks();
    }
    
    function moveArchiveDate(direction) {
        const currentDate = new Date(state.archiveViewDate);
        currentDate.setDate(currentDate.getDate() + direction);
        state.archiveViewDate = getFormattedDate(currentDate);
        renderArchive();
    }

    function escapeHtml(s) {
        return s?.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;') || '';
    }

    function formatTaskName(text) {
        if (!text) return '';
        let escaped = escapeHtml(text);
        // Process markdown links first to avoid them being treated as simple URLs
        escaped = escaped.replace(/\[(.*?)\]\((.*?)\)/g, (match, linkText, url) =>
            `<a href="${url.replace(/&amp;/g, '&')}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${linkText}</a>`);
        // Then process simple URLs, ensuring they are not inside an existing <a> tag's href attribute.
        return escaped.replace(/(?<!href=["'])(https?:\/\/\S+)/g, url =>
            `<a href="${url.replace(/&amp;/g, '&')}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${url}</a>`);
    }
    
    function calculateActualTime(task) {
        if (task.status === 'running' && task.startTime) {
             return Math.round((Date.now() - new Date(task.startTime).getTime()) / 1000);
        }
        if (task.startTime && task.endTime) {
            return Math.round(Math.max(0, new Date(task.endTime) - new Date(task.startTime)) / 1000);
        }
        return task.actualTime || 0;
    }

    function saveAndRender() { saveState(); render(); }
    function updateTimeDisplays() {
        currentDateEl.textContent = new Date().toLocaleString('ja-JP', { year:'numeric', month:'long', day:'numeric', weekday:'long' });
        calculateAllEstimates();
    }
    function formatTime(seconds) {
        const s = parseInt(seconds, 10) || 0;
        return new Date(s * 1000).toISOString().slice(11, 19);
    }
    function formatClockTime(date) {
        return date ? new Date(date).toLocaleTimeString('ja-JP', { hour:'2-digit', minute:'2-digit' }) : '--:--';
    }

    init();
});
</script>

</body>
</html>
