<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="DTL" />
    <title>DailyTaskList</title>
    <script src="https://cdn.tailwindcss.com"></script>
	<link href='./dtlfavicon.ico' rel='icon' type='image/x-icon'/>
    <link href='./dtlicon.png' rel='shortcut icon'/>
    <link href='./dtlicon.png' rel='apple-touch-icon'/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        
        /* header for desktop */
        @media (min-width: 769px) {
            .header {
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
			.sections-wrapper { padding-bottom:88px; }
        }
        
        /* Compact header for mobile */
        @media (max-width: 768px) {
            .header {
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .mobile-compact-header .header-content {
                padding: 8px 16px !important;
                flex-direction: row !important;
                align-items: center !important;
            }
            .mobile-compact-header h1 {
                display: none;
            }
			p#current-date { color: #333; font-size: 1rem; }
            .mobile-compact-header .header-stats p:first-child {
                font-size: 0.7rem;
            }
            .mobile-compact-header .header-stats p:last-child {
                font-size: 1.1rem;
            }
            .mobile-nav {
                padding: 0 !important;
            }
            .mobile-nav .tab-link {
                padding: 6px 12px !important;
                font-size: 0.8rem !important;
            }
        }
        
        .tab-link.active { border-color: #3b82f6; background-color:#3b82f6; color:white; }
        .tab-content { display:none; }
        .tab-content.active { display:block; }
        .task-row.focused { background-color: #fef9c3; }
        .task-card.focused { background-color: #fef9c3; border-color: #eab308; }
        ::-webkit-scrollbar { width:8px; height:0px; }
        ::-webkit-scrollbar-track { background:#f1f1f1; border-radius:10px; }
        ::-webkit-scrollbar-thumb { background:#888; border-radius:10px; }
        ::-webkit-scrollbar-thumb:hover { background:#555; }

        .timer-btn {
            height: 33px;
            width: 33px;
            min-height: 33px;
            min-width: 33px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }
        .task-table th, .task-table td {
             padding-top: 0.25rem;
             padding-bottom: 0.25rem;
             padding-left: 0.5rem;
             padding-right: 0.5rem;
        }
        
        .small-btn { min-height:44px; min-width:44px; display:inline-flex; align-items:center; justify-content:center; }
        .add-task-fab { display:block; position:fixed; right:16px; bottom:16px; z-index:60; }
        .sync-data-fab { display:none; position:fixed; left:16px; bottom:16px; z-index:60; }
        .inline-input, .inline-select { width:100%; box-sizing:border-box; padding:6px 8px; border-radius:6px; border:1px solid #d1d5db; }
        .small-btn { padding:6px 8px; border-radius:6px; font-size:0.9rem; }

        .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); }
        .modal.active { display:flex; align-items:center; justify-content:center; }
        .modal-content { background:white; border-radius:8px; max-width:90vw; max-height:90vh; overflow-y:auto; }
		
		#floating-task-bar { display: none; }

        .tooltip-container { position: relative; display: inline-flex; align-items: center; }
        .custom-tooltip { visibility: hidden; opacity: 0; background-color: #2d3748; color: #fff; text-align: left; border-radius: 6px; padding: 8px 12px; position: absolute; z-index: 10; bottom: 150%; left: 50%; transform: translateX(-50%); transition: opacity 0.1s, visibility 0.1s; width: max-content; max-width: 300px; font-size: 0.875rem; font-weight: normal; line-height: 1.4; white-space: pre-wrap; box-shadow: 0 4px 6px rgba(0,0,0,0.1); pointer-events: none; }
        .custom-tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #2d3748 transparent transparent transparent; }
        
        .tooltip-container:hover .custom-tooltip { 
            visibility: visible; 
            opacity: 1; 
            transition-delay: 0.1s; 
        }
        .tooltip-container:hover .custom-tooltip.tooltip-top { 
            bottom: 150%; 
            top: auto; 
        }
        .tooltip-container:hover .custom-tooltip.tooltip-bottom { 
            top: 150%; 
            bottom: auto; 
        }
        .custom-tooltip.tooltip-bottom::after { 
            top: -10px; 
            bottom: auto; 
            border-color: transparent transparent #2d3748 transparent; 
        }

        .dragging { opacity: 0.5; background-color: #fef9c3; }
        .drag-over { background-color: #e0f2fe; }
        .drag-handle { cursor: move; color: #9ca3af; }
        .drag-handle:hover { color: #6b7280; }

        .archive-tabs { border-bottom: 1px solid #e5e7eb; }
        .archive-tab { padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent; }
        .archive-tab.active { border-bottom-color: #3b82f6; background-color: #eff6ff; }
        .archive-tab:hover { background-color: #f3f4f6; }

        .time-input { width: 80px; text-align: center; border: 1px solid #d1d5db; border-radius: 4px; padding: 2px 4px; }

		.archive-search-box { display:flex; gap:8px; align-items:center; margin-bottom:12px; }
        .archive-search-input { flex:1; padding:8px 10px; max-width: 50%; border-radius:6px; border:1px solid #d1d5db; background:white; }
        .archive-search-btn { padding:8px 12px; border-radius:6px; background:#3b82f6; color:white; border:none; cursor:pointer; }
        .archive-clear-btn { padding:8px 10px; border-radius:6px; background:#e5e7eb; color:#374151; border:none; cursor:pointer; }
        .search-result-meta { font-size:0.85rem; color:#6b7280; }

        @media (max-width: 768px) {
            .sections-wrapper { padding-bottom:88px; }
            .task-card-wrapper {
                space-y: 0.5rem; 
            }
            .task-card {
                border-radius: 0;
            }
            .task-card.completed {
                background-color: #e5e7eb; 
            }
			#floating-task-bar.active {
			    display: flex;
			    transform: translateY(0);
				width: 60%;
                justify-self: center;
			}
			.add-task-fab, .sync-data-fab {
			    transition: bottom 0.3s ease-in-out;
			}
            
            .archive-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .archive-table-wrapper > table {
                min-width: 640px; 
            }
            .archive-table-wrapper td, .archive-table-wrapper th {
                white-space: nowrap; 
            }
            .archive-table-wrapper .task-memo-cell {
                white-space: normal;
                min-width: 250px;
            }
        }
		
    </style>
</head>
<body class="antialiased text-gray-800">

<div class="header">
    <div class="container mx-auto max-w-7xl">
        <header class="mobile-compact-header bg-white p-4 pb-1 flex flex-col md:flex-row justify-between items-center header-content">
            <div class="flex-1">
                <h1 class="text-xl font-bold text-gray-700">DailyTaskList</h1>
                <p id="current-date" class="text-sm text-gray-500"></p>
            </div>
            <div class="mt-2 md:mt-0 text-center md:text-right header-stats">
                <p class="text-gray-600">全体の終了予測</p>
                <p id="total-estimated-end-time" class="text-2xl font-semibold text-blue-600">--:--</p>
            </div>
        </header>

        <nav class="mobile-nav flex space-x-0 border-b-2 border-gray-200 overflow-x-auto">
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="today">当日のタスク</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="repeat">リピートタスク</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="projects">プロジェクト</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="archive">アーカイブ</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="data">データ管理</button>
        </nav>
    </div>
</div>

<div class="container mx-auto p-4 max-w-7xl">

    <main>
        <div id="today" class="tab-content space-y-4">
             <div class="flex justify-between items-center">
                 <div id="today-date-nav" class="flex items-center gap-2">
                    <button id="prev-day-btn" class="p-2 rounded-md bg-white hover:bg-gray-100 shadow-sm">&lt;</button>
                    <h2 id="view-date-display" class="font-bold text-lg"></h2>
                    <button id="next-day-btn" class="p-2 rounded-md bg-white hover:bg-gray-100 shadow-sm">&gt;</button>
                 </div>
                <p class="text-sm text-gray-500 hidden md:block">キーボード: [↑][↓]選択, [Space]開始/停止, [P]先送り, [Ctrl+↑][↓]移動, [N]新規, [E]編集, [M]メモ, [D]削除</p>
            </div>
            <div id="sections-container" class="sections-wrapper"></div>
        </div>

        <div id="repeat" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">リピートタスク管理</h2>
                <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4 items-end">
                    <input type="text" id="repeat-task-name" placeholder="タスク名" class="md:col-span-2 p-2 border rounded-lg">
                    <div class="grid grid-cols-2 gap-4">
                        <input type="number" id="repeat-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                        <select id="repeat-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
                    </div>
                    <select id="repeat-task-type" class="p-2 border rounded-lg bg-white md:col-span-2">
                        <option value="daily">毎日</option>
                        <option value="weekly">毎週</option>
                        <option value="monthly">毎月</option>
                        <option value="interval">○日ごと</option>
                    </select>
                </div>

                <div class="mb-4">
                    <textarea id="repeat-task-memo" placeholder="メモ (任意)" class="w-full p-2 border rounded-lg h-20"></textarea>
                </div>

                <div id="repeat-weekly-options" class="hidden flex flex-wrap gap-x-4 gap-y-2 mb-4 p-3 bg-gray-50 rounded-lg"></div>
                <div id="repeat-monthly-options" class="hidden mb-4 p-3 bg-gray-50 rounded-lg">
                    <label class="text-sm">日付: <input type="number" id="repeat-monthly-day" placeholder="1～31" class="p-2 border rounded-lg w-24" min="1" max="31"></label>
                </div>
                <div id="repeat-interval-options" class="hidden mb-4 p-3 bg-gray-50 rounded-lg space-y-2 md:space-y-0 md:items-center md:space-x-4">
                    <label class="text-sm">何日ごと: <input type="number" id="repeat-interval-days" placeholder="例: 3" class="p-2 border rounded-lg w-24" min="1"></label>
                    <label class="text-sm">基準日: <input type="date" id="repeat-interval-start-date" class="p-2 border rounded-lg"></label>
                </div>

                <div class="flex gap-3">
                    <button id="add-repeat-task-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ リピートタスクを追加</button>
                    <button id="generate-from-repeat-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">▶ 今日のタスクを生成</button>
                </div>

                <div id="repeat-tasks-container" class="mt-6"></div>
            </div>
        </div>

        <div id="projects" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">プロジェクト管理</h2>
                <div class="flex flex-wrap gap-4 items-center mb-4">
                    <input type="text" id="project-name" placeholder="プロジェクト名" class="flex-grow p-2 border rounded-lg">
                    <input type="color" id="project-color" value="#4a90e2" class="p-1 h-10 w-12 border rounded-lg">
                    <button id="add-project-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ プロジェクトを追加</button>
                </div>
                <div id="projects-container" class="mt-6"></div>
            </div>
        </div>
        
        <div id="archive" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="archive-tabs flex mb-4">
                    <div class="archive-tab active" data-view="date">日付</div>
                    <div class="archive-tab" data-view="project">プロジェクト</div>
					<div class="archive-tab" data-view="search">検索</div>
                </div>
                
                <div id="archive-date-view">
                    <div class="flex justify-between items-center mb-4">
                        <button id="prev-archive-day" class="p-2 rounded-md bg-gray-200 hover:bg-gray-300">&lt;</button>
                        <h2 id="archive-date" class="font-bold"></h2>
                        <button id="next-archive-day" class="p-2 rounded-md bg-gray-200 hover:bg-gray-300">&gt;</button>
                    </div>
                    <div id="archive-tasks-list"></div>
                </div>

                <div id="archive-project-view" class="hidden">
                    <div class="mb-4">
                        <select id="archive-project-select" class="p-2 border rounded-lg bg-white">
                            <option value="">プロジェクトを選択</option>
                        </select>
                    </div>
                    <div id="archive-project-tasks"></div>
                </div>

				<div id="archive-search-view" class="hidden">
    				<div class="archive-search-box">
        				<input id="archive-search-input" class="archive-search-input" type="text" placeholder="タスク名またはメモを検索">
        				<button id="archive-search-btn" class="archive-search-btn">検索</button>
        				<button id="archive-clear-btn" class="archive-clear-btn">クリア</button>
    				</div>
    				<div id="archive-search-results"></div>
				</div>
				
            </div>
        </div>

        <div id="data" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">データ管理</h2>
                <div class="space-y-6">
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">Dropbox</h3>
                        <p class="text-sm text-gray-600 mb-3">タスクデータをDropboxに保存し、他のデバイスと同期します。</p>
                        <div id="auth-container">
                            <button id="authorize_button" class="bg-blue-700 hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg">Dropbox ログイン</button>
                        </div>
                        <div id="signout_container" class="hidden">
                            <p id="auth-status" class="text-sm text-green-600 mb-2"></p>
                            <button id="signout_button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">ログアウト</button>
                        </div>
                        <p id="drive-status" class="text-sm text-gray-500 mt-2"></p>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">データエクスポート</h3>
                        <p class="text-sm text-gray-600 mb-3">現在のデータをJSONファイルとしてダウンロードします。</p>
                        <button id="export-data-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">データをエクスポート</button>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">データインポート</h3>
                        <p class="text-sm text-gray-600 mb-3">JSONファイルからデータを復元します。IDが重複するデータは上書きされ、存在しないデータは追加されます。</p>
                        <input type="file" id="import-file" accept=".json" class="mb-3 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                        <button id="import-data-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">データをインポート</button>
                    </div>
                    <div class="border p-4 rounded-lg border-red-200">
                        <h3 class="text-lg font-semibold mb-3 text-red-700">データ削除</h3>
                        <p class="text-sm text-gray-600 mb-3">全てのデータを削除します。この操作は元に戻せません。</p>
                        <button id="clear-data-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">全データを削除</button>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>

<button id="add-task-fab" class="add-task-fab bg-blue-600 text-white w-12 h-12 rounded-full shadow-lg flex items-center justify-center text-2xl">＋</button>

<div id="floating-task-bar" class="fixed bottom-3 inset-x-4 bg-white dark:bg-gray-800/90 backdrop-blur-sm rounded-lg shadow-lg p-2.5 z-50 items-center justify-between gap-3 transition-transform duration-300 transform translate-y-24">
</div>
	
<button id="sync-data-fab" class="sync-data-fab bg-green-600 hover:bg-green-700 text-white w-12 h-12 rounded-full shadow-lg items-center justify-center">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
    </svg>
</button>


<div id="add-task-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">タスクを追加</h3>
        <div class="space-y-4">
            <input type="text" id="new-task-name" placeholder="タスク名" class="w-full p-2 border rounded-lg">
            <input type="number" id="new-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg" value="5">
            <select id="new-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
        </div>
        <div class="flex gap-3 mt-6">
            <button id="save-new-task-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">追加</button>
            <button id="cancel-add-task-btn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>


<div id="task-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">タスクを編集</h3>
        <div class="space-y-4">
            <input type="text" id="edit-task-name" placeholder="タスク名" class="w-full p-2 border rounded-lg">
            <div class="grid grid-cols-2 gap-4">
                 <input type="number" id="edit-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                 <select id="edit-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
            </div>
            <textarea id="edit-task-memo" placeholder="メモ" class="w-full p-2 border rounded-lg h-20"></textarea>
            <div class="grid grid-cols-2 gap-4">
                 <div>
                    <label for="edit-task-startTime" class="text-sm font-medium text-gray-700">開始時刻</label>
                    <input type="time" id="edit-task-startTime" class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label for="edit-task-endTime" class="text-sm font-medium text-gray-700">終了時刻</label>
                    <input type="time" id="edit-task-endTime" class="w-full p-2 border rounded-lg">
                </div>
            </div>
        </div>
        <div class="flex gap-3 mt-6">
            <button id="save-task-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-task-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
            <button id="create-repeat-from-task" class="flex-1 bg-green-500 hover:bg-green-600 text-white py-2 px-2 rounded-lg">リピート作成</button>
        </div>
    </div>
</div>

<div id="memo-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">メモを編集</h3>
        <textarea id="edit-memo-text" placeholder="メモを入力..." class="w-full p-2 border rounded-lg h-32"></textarea>
        <div class="flex gap-3 mt-6">
            <button id="save-memo-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-memo-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="repeat-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-lg">
        <h3 class="text-lg font-bold mb-4">リピートタスクを編集</h3>
        <div class="space-y-4">
            <input type="text" id="edit-repeat-name" placeholder="タスク名" class="w-full p-2 border rounded-lg">
             <div class="grid grid-cols-2 gap-4">
                <input type="number" id="edit-repeat-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                <select id="edit-repeat-project" class="w-full p-2 border rounded-lg bg-white"></select>
            </div>
            <textarea id="edit-repeat-memo" placeholder="メモ" class="w-full p-2 border rounded-lg h-20"></textarea>
            <select id="edit-repeat-type" class="w-full p-2 border rounded-lg bg-white">
                <option value="daily">毎日</option>
                <option value="weekly">毎週</option>
                <option value="monthly">毎月</option>
                <option value="interval">○日ごと</option>
            </select>
        </div>

        <div id="edit-repeat-weekly-options" class="hidden flex flex-wrap gap-x-4 gap-y-2 mt-4 p-3 bg-gray-50 rounded-lg"></div>
        <div id="edit-repeat-monthly-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg">
            <label class="text-sm">日付: <input type="number" id="edit-repeat-monthly-day" placeholder="1～31" class="p-2 border rounded-lg w-24" min="1" max="31"></label>
        </div>
        <div id="edit-repeat-interval-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg space-y-2 md:space-y-0 md:items-center md:space-x-4">
            <label class="text-sm">何日ごと: <input type="number" id="edit-repeat-interval-days" placeholder="例: 3" class="p-2 border rounded-lg w-24" min="1"></label>
            <label class="text-sm">基準日: <input type="date" id="edit-repeat-interval-start-date" class="p-2 border rounded-lg"></label>
        </div>

        <div class="flex gap-3 mt-6">
            <button id="save-repeat-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-repeat-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="toast-notification" class="fixed top-5 right-5 bg-green-600 text-white py-2 px-4 rounded-lg shadow-md transition-all duration-500 ease-in-out transform -translate-y-20 opacity-0 z-[2000]"></div>

<script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- DROPBOX SYNC START ---
        const dailyTaskListApp = window.dailyTaskListApp = {
            dropboxFilePath: '/DailyTaskListData.json', // Dropbox App Folder内のパス
            dbx: null,
            saveTimeout: null,
            // DOM Elements
            authorizeButton: document.getElementById('authorize_button'),
            signoutButton: document.getElementById('signout_button'),
            authContainer: document.getElementById('auth-container'),
            signoutContainer: document.getElementById('signout_container'),
            authStatusEl: document.getElementById('auth-status'),
            driveStatusEl: document.getElementById('drive-status'),
            syncDataFab: document.getElementById('sync-data-fab'),

            updateAuthUi: function(isLoggedIn) {
                this.authContainer.classList.toggle('hidden', isLoggedIn);
                this.signoutContainer.classList.toggle('hidden', !isLoggedIn);
                
                if (isLoggedIn) {
                    this.authStatusEl.textContent = 'Dropboxにログイン済みです。';
                    this.syncDataFab.style.display = 'flex';
                } else {
                    this.driveStatusEl.textContent = 'ログインするとデータを同期できます。';
                    this.syncDataFab.style.display = 'none';
                }
            },

            loadStateFromDropbox: async function() {
                if (!this.dbx) {
                    alert('Dropboxにログインしてください。');
                    return;
                }
                this.driveStatusEl.textContent = 'Dropboxからデータを読み込み中...';
                try {
                    const response = await this.dbx.filesDownload({ path: this.dropboxFilePath });
                    const fileContent = await response.result.fileBlob.text();
                    const importedData = JSON.parse(fileContent);

                    // --- Custom Merge Logic for dailyTasks ---
                    const driveDailyTasks = importedData.dailyTasks || {};
                    const localDailyTasks = state.dailyTasks;
                    const allDailyDates = new Set([...Object.keys(localDailyTasks), ...Object.keys(driveDailyTasks)]);
                    allDailyDates.forEach(date => {
                        const localTasksForDate = localDailyTasks[date] || [];
                        const driveTasksForDate = driveDailyTasks[date] || [];
                        const combinedTasks = [...localTasksForDate, ...driveTasksForDate];
                        const taskMap = new Map();
                        for (const task of combinedTasks) {
                            const key = task.originRepeatId ? `repeat-${date}-${task.originRepeatId}` : `task-${task.id}`;
                            if (taskMap.has(key)) {
                                const existingTask = taskMap.get(key);
                                // 開始/終了時間が異なるかチェック
                                const timesAreDifferent = (
                                    (task.startTime || null) !== (existingTask.startTime || null) ||
                                    (task.endTime || null) !== (existingTask.endTime || null)
                                );
                                // 手動タスク（リピート由来でない）で、かつ時間が異なる場合
                                if (!task.originRepeatId && timesAreDifferent) {
                                    // 新しい方のタスクのIDを振り直し、別タスクとして追加
                                    const newTask = { ...task, id: task.id + '_dup_' + Date.now() };
                                    const newKey = `task-${newTask.id}`;
                                    taskMap.set(newKey, newTask);
                                    // 既存のタスクはマップに残したままにする
                                } else {
                                    // 時間が同じか、リピートタスクの場合は、従来の優先度比較で上書き
                                    const getTaskPriority = (t) => {
                                        if (getTaskStatus(t) === 'completed') return 2;
                                        if (getTaskStatus(t) === 'running') return 1;
                                        return 0;
                                    };
                                    // より状態が進んでいるタスクを優先する
                                    if (getTaskPriority(task) >= getTaskPriority(existingTask)) {
                                        taskMap.set(key, task);
                                    }
                                }
                            } else {
                                taskMap.set(key, task);
                            }
                        }
                        state.dailyTasks[date] = Array.from(taskMap.values());
						state.dailyTasks[date].sort((a, b) => {
						    const statusA = getTaskStatus(a);
						    const statusB = getTaskStatus(b);
						    const statusOrder = { completed: 0, running: 1, pending: 2 };
						    const orderA = statusOrder[statusA];
						    const orderB = statusOrder[statusB];
						
						    if (orderA !== orderB) {
						        return orderA - orderB;
						    }
						    
						    // ステータスが同じ場合、開始時刻の昇順でソート
						    const startTimeA = a.startTime ? new Date(a.startTime).getTime() : Infinity;
						    const startTimeB = b.startTime ? new Date(b.startTime).getTime() : Infinity;
						    return startTimeA - startTimeB;
						});
                    });
                    // --- End of dailyTasks Merge Logic ---

                    // --- Custom Merge Logic for archivedTasks ---
                    const driveArchivedTasks = importedData.archivedTasks || {};
                    const localArchivedTasks = state.archivedTasks;
                    const allArchiveDates = new Set([...Object.keys(localArchivedTasks), ...Object.keys(driveArchivedTasks)]);
                    allArchiveDates.forEach(date => {
                        const localTasks = localArchivedTasks[date] || [];
                        const driveTasks = driveArchivedTasks[date] || [];
                        const taskMap = new Map();
                        for (const task of [...localTasks, ...driveTasks]) {
                            taskMap.set(task.id, task);
                        }
                        state.archivedTasks[date] = Array.from(taskMap.values());
                    });
                    // --- End of archivedTasks Merge Logic ---

                    if (importedData.projects) state.projects = importedData.projects;
                    if (importedData.repeatTasks) state.repeatTasks = importedData.repeatTasks;
                    state.lastDate = importedData.lastDate || state.lastDate;
                    
                    stopActiveTimer();
                    state.viewDate = getFormattedDate(new Date());
                    const tasksToday = getTasksForViewDate();
                    const firstUncompletedTask = tasksToday.find(t => getTaskStatus(t) !== 'completed');
					state.focusedTaskId = firstUncompletedTask ? firstUncompletedTask.id : (tasksToday.length > 0 ? tasksToday[0].id : null);
                    Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
                    
                    saveState(); 
                    render();
                    this.driveStatusEl.textContent = `Dropboxからデータを読み込みました (${new Date().toLocaleTimeString()})。`;
                    showToast('Dropboxからデータを読み込み、マージしました。');

                } catch (error) {
                    if (error.status === 409) { // 409: path not found
                         this.driveStatusEl.textContent = 'データファイルが見つかりません。初回同期を開始します...';
                         await this.saveStateToDropbox(); // 初回保存
                    } else {
                        console.error('Error loading state from Dropbox:', error);
                        this.driveStatusEl.textContent = `読み込みエラー: ${error.error?.error_summary || 'Unknown error'}`;
                    }
                }
            },
            
            saveStateToDropbox: async function() {
                if (!this.dbx) return;
                
                this.driveStatusEl.textContent = 'Dropboxへ保存準備中...';
                const dataToSave = {
                    dailyTasks: state.dailyTasks,
                    projects: state.projects,
                    repeatTasks: state.repeatTasks,
                    archivedTasks: state.archivedTasks,
                    lastDate: state.lastDate,
                    updatedAt: new Date().toISOString()
                };
                
                this.driveStatusEl.textContent = 'Dropboxへ保存中...';
                try {
                    await this.dbx.filesUpload({
                        path: this.dropboxFilePath,
                        contents: JSON.stringify(dataToSave, null, 2),
                        mode: 'overwrite'
                    });
                    this.driveStatusEl.textContent = `Dropboxに保存しました (${new Date().toLocaleTimeString()})。`;
                } catch (error) {
                    console.error('Error saving state to Dropbox:', error);
                    this.driveStatusEl.textContent = `保存エラー: ${error.error?.error_summary || 'Unknown error'}`;
                     if (error.status === 401) { // 認証エラー
                           this.updateAuthUi(false);
                           this.driveStatusEl.textContent = '認証が切れました。再ログインしてください。';
                    }
                }
            }
        };
        
		// Dropbox 同期機能の初期化
		async function initializeDropboxSync() {
		    // ここにDropboxアプリのクライアントIDを設定してください
		    const DROPBOX_CLIENT_ID = '0fno7q10xgfdyki';
		    const REDIRECT_URI = window.location.origin + window.location.pathname; 
		    // 例: https://morvra.github.io/dtl または https://morvra.github.io/dtl/
		
		    if (DROPBOX_CLIENT_ID === 'YOUR_CLIENT_ID') {
		        console.warn("DropboxのクライアントIDが設定されていません。");
		        dailyTaskListApp.authorizeButton.textContent = '設定が必要です';
		        dailyTaskListApp.authorizeButton.disabled = true;
		        return;
		    }
		
		    const dbx = new Dropbox.Dropbox({ clientId: DROPBOX_CLIENT_ID });
		
		    // URLに認証コードがあるか確認 (OAuthリダイレクト後)
		    const urlParams = new URLSearchParams(window.location.search);
		    const authCode = urlParams.get('code');
		
		    if (authCode) {
		        try {
		            // --- PKCE: 認証開始時に保存した code_verifier を復元 ---
		            const savedVerifier = sessionStorage.getItem('dropbox_pkce_code_verifier');
		            if (savedVerifier && dbx && dbx.auth) {
		                try { dbx.auth.codeVerifier = savedVerifier; } catch (e) { /* ignore */ }
		            }
		
		            // 認証コードをアクセストークンに交換
		            const response = await dbx.auth.getAccessTokenFromCode(REDIRECT_URI, authCode);
		            const accessToken =
		                (response.result && (response.result.access_token || response.result.accessToken)) ||
		                response.accessToken;
		
		            // 交換が成功したら、保存しておいた verifier は削除
		            sessionStorage.removeItem('dropbox_pkce_code_verifier');
		
		            // URLから認証コードを削除してクリーンにする
		            window.history.replaceState({}, document.title, window.location.pathname);
		            localStorage.setItem('dropbox_access_token', accessToken);
		            dbx.auth.setAccessToken(accessToken);
		            dailyTaskListApp.dbx = dbx;
		            dailyTaskListApp.updateAuthUi(true);
		            dailyTaskListApp.loadStateFromDropbox();
		        } catch (error) {
		            console.error('Error getting access token from code:', error);
		            const detail =
		                (error && (error.error_summary || error.error || error.error_description)) ||
		                JSON.stringify(error);
		            dailyTaskListApp.driveStatusEl.textContent = `認証交換エラー: ${detail}`;
		            alert('Dropboxの認証に失敗しました。詳細はコンソールを確認してください。');
		        }
		    } else {
		        // ローカルストレージにトークンがあるか確認
		        const storedToken = localStorage.getItem('dropbox_access_token');
		        if (storedToken) {
					dbx.auth.setAccessToken(storedToken);
		            dailyTaskListApp.dbx = dbx;
		            // トークンの有効性を確認
		            try {
		                await dbx.usersGetCurrentAccount();
		                dailyTaskListApp.updateAuthUi(true);
		                dailyTaskListApp.loadStateFromDropbox();
		            } catch (error) {
		                // トークンが無効だった場合
		                console.error('Stored token invalid:', error);
		                localStorage.removeItem('dropbox_access_token');
		                dailyTaskListApp.dbx = null;
		                dailyTaskListApp.updateAuthUi(false);
		            }
		        } else {
		            dailyTaskListApp.updateAuthUi(false);
		        }
		    }
		
		    // --- 認証開始処理 ---
		    dailyTaskListApp.authorizeButton.addEventListener('click', async () => {
		        try {
		            const authUrl = await dbx.auth.getAuthenticationUrl(
		                REDIRECT_URI, // Redirect URI
		                undefined,    // state
		                'code',       // authType
		                undefined,    // tokenAccessType
		                undefined,    // scope
		                undefined,    // includeGrantedScopes
		                true          // usePKCE
		            );
		            // SDKが生成した code_verifier を sessionStorage に保存
		            try {
		                const codeVerifier = dbx.auth && dbx.auth.codeVerifier;
		                if (codeVerifier) {
		                    sessionStorage.setItem('dropbox_pkce_code_verifier', codeVerifier);
		                }
		            } catch (e) {
		                console.warn('Failed to store Dropbox PKCE code_verifier:', e);
		            }
		            // ユーザーをDropboxの認証ページへリダイレクト
		            window.location.href = authUrl;
		        } catch (e) {
		            console.error('Error creating Dropbox auth URL:', e);
		            alert('Dropbox認証用URLの生成に失敗しました。');
		        }
		    });
		
		    // --- ログアウト処理 ---
		    dailyTaskListApp.signoutButton.addEventListener('click', async () => {
		        if (!dailyTaskListApp.dbx) return;
		        try {
		            await dailyTaskListApp.dbx.authTokenRevoke();
		        } catch (error) {
		            console.error('Failed to revoke token', error);
		        } finally {
		            localStorage.removeItem('dropbox_access_token');
		            dailyTaskListApp.dbx = null;
		            dailyTaskListApp.updateAuthUi(false);
		        }
		    });
		}
		// --- DROPBOX SYNC END ---

        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast-notification');
            if (!toast) return;

            toast.textContent = message;
            toast.classList.remove('-translate-y-20', 'opacity-0');

            // 一定時間後に非表示
            setTimeout(() => {
                toast.classList.add('-translate-y-20', 'opacity-0');
            }, duration);
        }

        // State
        const state = {
            dailyTasks: {}, 
            projects: [],
            repeatTasks: [],
            archivedTasks: {},
            viewDate: null, 
            lastDate: null,
            archiveViewDate: null,
            archiveView: 'date',
            selectedArchiveProject: '',
            settings: {
                dayChangeHour: 4, 
            },
            activeTimerId: null,
            activeTaskId: null,
            focusedTaskId: null,
            editingTaskId: null,
            editingTaskDateKey: null, 
            editingRepeatId: null,
            editingMemoTaskId: null
        };

        // DOM refs
        const tabs = document.querySelectorAll('.tab-link');
        const currentDateEl = document.getElementById('current-date');
        const totalEstimatedEndTimeEl = document.getElementById('total-estimated-end-time');

        // Init
        function init() {
            state.viewDate = getFormattedDate(new Date());
            loadState();
            setupEventListeners();
            initializeDropboxSync();
            checkDayChange();
            setInterval(checkDayChange, 1000 * 60); 
            updateTitle();
            
            render();
            updateTimeDisplays();
            setInterval(updateTimeDisplays, 1000*30);
            
            window.addEventListener('resize', () => {
                const activeTab = document.querySelector('.tab-link.active').dataset.tab;
                if (['today', 'repeat', 'projects', 'archive'].includes(activeTab)) {
                    render();
                }
				renderFloatingTaskBar();
            });
        }

    function getTasksForViewDate() {
        return state.dailyTasks[state.viewDate] || [];
    }

    function setTasksForViewDate(tasks) {
        state.dailyTasks[state.viewDate] = tasks;
    }

	function updateTitle() {
        const activeTask = getTasksForViewDate().find(t => t.id === state.activeTaskId);
        if (activeTask) {
            document.title = `⏱ ${activeTask.name} - DTL`;
        } else {
            document.title = 'DailyTaskList';
        }
    }

    function isMobile() {
        return window.innerWidth <= 768;
    }

    function getFormattedDate(date) {
        return new Date(date.getTime() - (state.settings.dayChangeHour * 60 * 60 * 1000))
            .toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' })
            .replace(/\//g, '-');
    }

    function getTaskStatus(task) {
        if (task.startTime && task.endTime) {
            return 'completed';
        } else if (task.startTime && !task.endTime) {
            return 'running';
        } else {
            return 'pending';
        }
    }

    function updateTaskStatus(task) {
        const tasks = getTasksForViewDate();
        const oldStatus = task.status;
        task.status = getTaskStatus(task);
        
        if (oldStatus !== 'completed' && task.status === 'completed') {
            moveTaskToCompletedSection(task.id);
        }
        else if (oldStatus !== 'running' && task.status === 'running') {
            moveTaskToTop(task.id);
        }
    }

    function moveTaskToCompletedSection(taskId) {
        const tasks = getTasksForViewDate();
        const taskIndex = tasks.findIndex(t => t.id === taskId);
        if (taskIndex === -1) return;

        const [task] = tasks.splice(taskIndex, 1);
        
        const lastCompletedIndex = tasks.map(t => t.status === 'completed').lastIndexOf(true);
        
        const insertIndex = lastCompletedIndex === -1 ? 0 : lastCompletedIndex + 1;

        tasks.splice(insertIndex, 0, task);
        setTasksForViewDate(tasks);
    }

	function moveTaskToTop(taskId) {
	    const tasks = getTasksForViewDate();
	    const taskIndex = tasks.findIndex(t => t.id === taskId);
	    if (taskIndex !== -1) {
	        const task = tasks[taskIndex];
	        const uncompletedTasks = tasks.filter(t => t.status !== 'completed' && t.id !== taskId);
	
	        if (uncompletedTasks.length === 0) {
	            return;
	        }
	
	        const [movedTask] = tasks.splice(taskIndex, 1);
	        const firstUncompletedIndex = tasks.findIndex(t => t.status !== 'completed');
	        
	        const insertIndex = firstUncompletedIndex !== -1 ? firstUncompletedIndex : 0;
	        
	        tasks.splice(insertIndex, 0, movedTask);
	        setTasksForViewDate(tasks);
	    }
	}

    function positionTooltip(tooltipContainer) {
        const tooltip = tooltipContainer.querySelector('.custom-tooltip');
        const rect = tooltipContainer.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        
        if (rect.top - tooltipRect.height < 10) {
            tooltip.classList.add('tooltip-bottom');
            tooltip.classList.remove('tooltip-top');
        } else {
            tooltip.classList.add('tooltip-top');
            tooltip.classList.remove('tooltip-bottom');
        }
    }

    function loadState() {
        const defaults = {
            dailyTasks: {},
            projects: [
                { id: 'p' + Date.now(), name: '仕事', color: '#4a90e2' },
                { id: 'p' + (Date.now()+1), name: '学習', color: '#50e3c2' },
                { id: 'p' + (Date.now()+2), name: 'プライベート', color: '#f5a623' },
            ],
            repeatTasks: [],
            archivedTasks: {},
            lastDate: getFormattedDate(new Date()),
        };

        const oldTasks = localStorage.getItem('dtl_tasks');
        const newTasks = localStorage.getItem('dtl_dailyTasks');
        if (oldTasks && !newTasks) {
            const parsedOldTasks = JSON.parse(oldTasks);
            if (Array.isArray(parsedOldTasks) && parsedOldTasks.length > 0) {
                const today = getFormattedDate(new Date());
                state.dailyTasks[today] = parsedOldTasks;
                localStorage.removeItem('dtl_tasks');
            }
        }
        
        Object.keys(defaults).forEach(k => {
            const saved = localStorage.getItem(`dtl_${k}`);
            if ((k === 'archivedTasks' || k === 'dailyTasks') && !saved) {
                state[k] = defaults[k];
            } else {
                 state[k] = saved ? JSON.parse(saved) : defaults[k];
            }
        });
        
        Object.values(state.dailyTasks).flat().forEach(task => {
            updateTaskStatus(task);
        });
    }

	function saveState() {
		Object.keys(state).forEach(k => {
			if (k !== 'settings' && k !== 'archiveView' && k !== 'selectedArchiveProject') {
				localStorage.setItem(`dtl_${k}`, JSON.stringify(state[k]));
			}
		});
		const app = window.dailyTaskListApp;
		if (app.dbx) { // Dropboxインスタンスの有無で判定
			if (app.saveTimeout) clearTimeout(app.saveTimeout);
			app.saveTimeout = setTimeout(() => app.saveStateToDropbox(), 2000);
		}
	}
    
    function checkDayChange() {
        const today = getFormattedDate(new Date());
        if (state.lastDate !== today) {
            console.log(`Date changed: ${state.lastDate} -> ${today}`);

            const yesterdaysTasks = state.dailyTasks[state.lastDate];
            if (yesterdaysTasks && yesterdaysTasks.length > 0) {
                const leftoverTasks = yesterdaysTasks.filter(t => t.status !== 'completed');
                if (leftoverTasks.length > 0) {
                    if (!state.dailyTasks[today]) {
                        state.dailyTasks[today] = [];
                    }
                    state.dailyTasks[today].unshift(...leftoverTasks);
                    state.dailyTasks[state.lastDate] = yesterdaysTasks.filter(t => t.status === 'completed');
                }
            }
            
            archiveCompletedTasks(state.lastDate);
            generateTasksFromRepeatAuto(today);
            state.lastDate = today;
            state.viewDate = today; 
            state.focusedTaskId = (state.dailyTasks[today] && state.dailyTasks[today][0]?.id) || null;
            saveAndRender();
        }
    }

	// ページ読み込み時に実行中のタスクがあればタイマーを復元
	const tasksOnLoad = getTasksForViewDate();
	const runningTaskOnLoad = tasksOnLoad.find(t => t.status === 'running');
	if (runningTaskOnLoad) {
	    state.activeTaskId = runningTaskOnLoad.id;
	    state.activeTimerId = setInterval(() => {
	        const currentActualTime = calculateActualTime(runningTaskOnLoad);
	        const timeEl = document.querySelector(`[data-task-id="${runningTaskOnLoad.id}"] .time-actual`);
	        if (timeEl) {
	            timeEl.textContent = formatTime(currentActualTime);
	        }
	    }, 1000);
	}

    function archiveCompletedTasks(dateKey) {
        if (!state.dailyTasks[dateKey]) return;

        const completedTasks = state.dailyTasks[dateKey].filter(t => t.status === 'completed');
        if (completedTasks.length > 0) {
            if (!state.archivedTasks[dateKey]) {
                state.archivedTasks[dateKey] = [];
            }
            state.archivedTasks[dateKey].push(...completedTasks);
            state.dailyTasks[dateKey] = state.dailyTasks[dateKey].filter(t => t.status !== 'completed');
        }
    }

    function generateTasksFromRepeatAuto(dateStr) {
        const today = new Date(dateStr);
        today.setMinutes(today.getMinutes() + today.getTimezoneOffset());
        
        const dayOfWeek = today.getDay();
        const dayOfMonth = today.getDate();

        if (!state.dailyTasks[dateStr]) {
            state.dailyTasks[dateStr] = [];
        }

        state.repeatTasks.forEach(rt => {
            let shouldAdd = false;
            
            if (rt.type === 'daily') shouldAdd = true;
            else if (rt.type === 'weekly' && Array.isArray(rt.value) && rt.value.includes(dayOfWeek)) shouldAdd = true;
            else if (rt.type === 'monthly' && rt.value == dayOfMonth) shouldAdd = true;
            else if (rt.type === 'interval' && rt.startDate && rt.value > 0) {
                const start = new Date(rt.startDate);
                start.setMinutes(start.getMinutes() + start.getTimezoneOffset());
                const diffTime = today.getTime() - start.getTime();
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                if (diffDays >= 0 && diffDays % rt.value === 0) shouldAdd = true;
            }

            if (shouldAdd) {
                const isAlreadyAdded = state.dailyTasks[dateStr].some(task => task.originRepeatId === rt.id);
                if (!isAlreadyAdded) {
                    state.dailyTasks[dateStr].push({
                        id: 't' + Date.now() + Math.random(),
                        name: rt.name,
                        projectId: rt.projectId || null,
                        estimatedTime: rt.estimatedTime || 0,
                        actualTime: 0,
                        status: 'pending',
                        isInterrupt: false,
                        memo: rt.memo || '',
                        originRepeatId: rt.id,
                        createdDate: dateStr,
                        startTime: null,
                        endTime: null,
                    });
                }
            }
        });
    }

    function generateTasksFromRepeatManual() {
        const todayStr = getFormattedDate(new Date());
        
        if (!state.dailyTasks[todayStr]) {
            state.dailyTasks[todayStr] = [];
        }
        let tasksForToday = state.dailyTasks[todayStr];

        let addedCount = 0;
        const tasksBefore = tasksForToday.length;
        
        generateTasksFromRepeatAuto(todayStr);

        const tasksAfter = state.dailyTasks[todayStr].length;
        addedCount = tasksAfter - tasksBefore;

        if (addedCount > 0) {
            state.focusedTaskId = tasksForToday.length > 0 ? tasksForToday[tasksForToday.length-1].id : null;
            saveAndRender();
            alert(addedCount + ' 件のタスクを生成しました。');
        } else {
            alert('今日生成できるリピートタスクはありません（既に生成済みか該当なし）。');
        }
    }

    function generateSingleRepeatTask(repeatTaskId) {
        const rt = state.repeatTasks.find(t => t.id === repeatTaskId);
        if (!rt) return;

        const today = getFormattedDate(new Date());
        if (!state.dailyTasks[today]) state.dailyTasks[today] = [];
        const tasksForToday = state.dailyTasks[today];
        
        const existingTask = tasksForToday.find(t => 
            t.originRepeatId === repeatTaskId && 
            t.createdDate === today
        );
        
        if (existingTask) {
            alert('このリピートタスクは既に今日のタスクとして存在します。');
            return;
        }

        const newTask = {
            id: 't' + Date.now() + Math.random(),
            name: rt.name,
            projectId: rt.projectId || null,
            estimatedTime: rt.estimatedTime || 0,
            actualTime: 0,
            status: 'pending',
            isInterrupt: false,
            memo: rt.memo || '',
            originRepeatId: rt.id,
            createdDate: today,
            startTime: null,
            endTime: null,
        };

        const lastPendingIndex = tasksForToday.map(t => t.status).lastIndexOf('pending');
        const lastRunningIndex = tasksForToday.map(t => t.status).lastIndexOf('running');
        const lastUncompletedIndex = Math.max(lastPendingIndex, lastRunningIndex);
        
        const insertIndex = lastUncompletedIndex !== -1 ? lastUncompletedIndex + 1 : tasksForToday.length;
        tasksForToday.splice(insertIndex, 0, newTask);
        setTasksForViewDate(tasksForToday);

        state.focusedTaskId = newTask.id;
        state.viewDate = today;
        saveAndRender();
        alert('今日のタスクとして追加しました。');
    }

    function setupEventListeners() {
        document.getElementById('sync-data-fab').addEventListener('click', () => {
            dailyTaskListApp.loadStateFromDropbox();
        });

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
                
                if (tab.dataset.tab === 'today') {
                    const tasks = getTasksForViewDate();
                    state.focusedTaskId = tasks.find(t => t.status !== 'completed')?.id || tasks[0]?.id || null;
                } else if (tab.dataset.tab === 'archive') {
                    if (!state.archiveViewDate) {
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        state.archiveViewDate = getFormattedDate(yesterday);
                    }
                }
                render();
            });
        });
        document.querySelector('.tab-link[data-tab="today"]').click();

        document.getElementById('add-task-fab').addEventListener('click', openAddTaskModal);
        document.getElementById('add-project-btn').addEventListener('click', addProject);
        document.getElementById('add-repeat-task-btn').addEventListener('click', addRepeatTask);
        document.getElementById('generate-from-repeat-btn').addEventListener('click', generateTasksFromRepeatManual);
        
        document.getElementById('repeat-task-type').addEventListener('change', (e) => {
            document.getElementById('repeat-weekly-options').classList.toggle('hidden', e.target.value !== 'weekly');
            document.getElementById('repeat-monthly-options').classList.toggle('hidden', e.target.value !== 'monthly');
            document.getElementById('repeat-interval-options').classList.toggle('hidden', e.target.value !== 'interval');
            if (e.target.value === 'interval') {
                const startDateInput = document.getElementById('repeat-interval-start-date');
                if (!startDateInput.value) {
                    startDateInput.value = new Date().toISOString().slice(0, 10);
                }
            }
        });
        
        document.getElementById('prev-day-btn').addEventListener('click', () => moveViewDate(-1));
        document.getElementById('next-day-btn').addEventListener('click', () => moveViewDate(1));
        document.getElementById('prev-archive-day').addEventListener('click', () => moveArchiveDate(-1));
        document.getElementById('next-archive-day').addEventListener('click', () => moveArchiveDate(1));

        document.querySelectorAll('.archive-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.archive-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                state.archiveView = tab.dataset.view;
                renderArchive();
            });
        });

        document.getElementById('archive-project-select').addEventListener('change', (e) => {
            state.selectedArchiveProject = e.target.value;
            renderArchiveProjectView();
        });

		const searchBtn = document.getElementById('archive-search-btn');
		const searchInput = document.getElementById('archive-search-input');
		const clearBtn = document.getElementById('archive-clear-btn');
		if (searchBtn && searchInput && clearBtn) {
    		searchBtn.addEventListener('click', () => {
        		const q = searchInput.value.trim();
        		renderArchiveSearchView(q);
    		});
    		clearBtn.addEventListener('click', () => {
        		searchInput.value = '';
        		renderArchiveSearchView('');
    		});
    		searchInput.addEventListener('keydown', (e) => {
        		if (e.key === 'Enter') {
            		e.preventDefault();
            		const q = searchInput.value.trim();
            		renderArchiveSearchView(q);
        		}
    		});
		}

        document.getElementById('export-data-btn').addEventListener('click', exportData);
        document.getElementById('import-data-btn').addEventListener('click', importData);
        document.getElementById('clear-data-btn').addEventListener('click', clearAllData);

        setupModalEvents();

        document.addEventListener('keydown', handleKeyboardShortcuts);
        
        document.addEventListener('mouseover', (e) => {
            const tooltipContainer = e.target.closest('.tooltip-container');
            if (tooltipContainer) {
                setTimeout(() => positionTooltip(tooltipContainer), 10);
            }
        });
    }

    function setupModalEvents() {
        document.getElementById('save-new-task-btn').addEventListener('click', () => {
             addTask(
                document.getElementById('new-task-name').value,
                document.getElementById('new-task-time').value,
                document.getElementById('new-task-project').value
            );
            closeModal('add-task-modal');
        });
        document.getElementById('cancel-add-task-btn').addEventListener('click', () => closeModal('add-task-modal'));
        
        document.getElementById('save-task-edit').addEventListener('click', saveTaskEdit);
        document.getElementById('cancel-task-edit').addEventListener('click', () => closeModal('task-edit-modal'));
        document.getElementById('create-repeat-from-task').addEventListener('click', createRepeatFromTask);

        document.getElementById('edit-memo-text').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveMemoEdit();
            }
        });
        document.getElementById('save-memo-edit').addEventListener('click', saveMemoEdit);
        document.getElementById('cancel-memo-edit').addEventListener('click', () => closeModal('memo-edit-modal'));

        document.getElementById('save-repeat-edit').addEventListener('click', saveRepeatEdit);
        document.getElementById('cancel-repeat-edit').addEventListener('click', () => closeModal('repeat-edit-modal'));
        document.getElementById('edit-repeat-type').addEventListener('change', (e) => {
            document.getElementById('edit-repeat-weekly-options').classList.toggle('hidden', e.target.value !== 'weekly');
            document.getElementById('edit-repeat-monthly-options').classList.toggle('hidden', e.target.value !== 'monthly');
            document.getElementById('edit-repeat-interval-options').classList.toggle('hidden', e.target.value !== 'interval');
             if (e.target.value === 'interval') {
                const startDateInput = document.getElementById('edit-repeat-interval-start-date');
                if (!startDateInput.value) {
                    startDateInput.value = new Date().toISOString().slice(0, 10);
                }
            }
        });

        document.getElementById('new-task-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (document.getElementById('new-task-name').value.trim() === '') {
                    closeModal('add-task-modal');
                } else {
                    document.getElementById('save-new-task-btn').click();
                }
            }
        });

        document.getElementById('edit-task-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); saveTaskEdit(); }
        });

        document.getElementById('edit-repeat-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); saveRepeatEdit(); }
        });

        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal(modal.id);
            });
        });
    }

    function openModal(modalId) {
        document.getElementById(modalId).classList.add('active');
		renderFloatingTaskBar();
    }

    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('active');
        if (modalId === 'task-edit-modal') {
            state.editingTaskDateKey = null;
            state.editingTaskId = null;
        }
		renderFloatingTaskBar();
    }

    function render() {
        const activeTab = document.querySelector('.tab-link.active').dataset.tab;
        if (activeTab === 'today') renderTodayTasks();
        else if (activeTab === 'repeat') renderRepeatTasks();
        else if (activeTab === 'projects') renderProjects();
        else if (activeTab === 'archive') renderArchive();
        updateProjectDropdowns();
        calculateAllEstimates();
		updateTitle();
		renderFloatingTaskBar();
    }

    function renderTodayTasks() {
        const container = document.getElementById('sections-container');
        container.innerHTML = '';
        
        const viewDateObj = new Date(state.viewDate);
        const todayStr = getFormattedDate(new Date());
        let dateLabel = viewDateObj.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric', weekday: 'short' });

        document.getElementById('view-date-display').textContent = dateLabel;

        const prevBtn = document.getElementById('prev-day-btn');
        if (state.viewDate <= todayStr) {
            prevBtn.style.visibility = 'hidden';
        } else {
            prevBtn.style.visibility = 'visible';
        }

        const tasks = getTasksForViewDate();
        if (tasks.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">タスクはありません。[N]キーで追加できます。</p>`;
            return;
        }

        if (isMobile()) {
            renderTaskCards(container);
        } else {
            renderTaskTable(container);
        }

        const focusedEl = document.querySelector('.task-row.focused, .task-card.focused');
        if (focusedEl) focusedEl.scrollIntoView({ block:'nearest', behavior:'smooth' });
    }

    function renderTaskTable(container) {
        const tasks = getTasksForViewDate();
        const wrapper = document.createElement('div');
        wrapper.className = 'bg-white shadow-md';

        const tableContainer = document.createElement('div');
        tableContainer.className = 'overflow-x-auto';

        const table = document.createElement('table');
        table.className = 'min-w-full task-table';
        table.innerHTML = `
            <thead class="bg-gray-50">
                <tr>
                    <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                    <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">見積</th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-28">実績</th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">開始</th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">終了</th>
                    <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-28">操作</th>
                </tr>
            </thead>
            <tbody id="task-table-body"></tbody>
        `;

        const tbody = table.querySelector('tbody');
        tasks.forEach((task, index) => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const tr = document.createElement('tr');
            tr.className = `border-b task-row ${task.status === 'completed' ? 'bg-gray-100 text-gray-500' : ''} ${task.status === 'running' ? 'bg-blue-50' : ''} ${task.id === state.focusedTaskId ? 'focused' : ''}`;
            tr.dataset.taskId = task.id;
            tr.dataset.index = index;
            tr.draggable = true;

            const isRunning = task.status === 'running';
            const isCompleted = task.status === 'completed';

            let timerButtonHtml = '';
            if(isCompleted) {
                timerButtonHtml = `
                <button class="timer-btn checkmark-btn rounded-full bg-gray-200 hover:bg-gray-300 cursor-pointer items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-600" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                </button>`;
            } else {
                 timerButtonHtml = `<button class="timer-btn rounded-full transition-colors duration-200 ${isRunning ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}">
                    ${isRunning ? '■' : '▶'}
                </button>`;
            }

            const memoIcon = task.memo ? `
                <span class="tooltip-container memo-icon-clickable" data-task-id="${task.id}">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 text-gray-400 cursor-pointer hover:text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                    <span class="custom-tooltip">${escapeHtml(task.memo)}</span>
                </span>` : '';
            
            const actualTimeDisplay = `<span class="font-mono time-actual">${formatTime(calculateActualTime(task))}</span>`;

            tr.innerHTML = `
                <td class="text-center"><span class="drag-handle">⋮⋮</span></td>
                <td class="text-center">${timerButtonHtml}</td>
                <td>
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-1 min-w-0">
                            <span class="inline-block w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${project.color};"></span>
                            <span class="pl-1 font-semibold truncate" title="${escapeHtml(task.name || '')}">${formatTaskName(task.name)}</span>
                            ${memoIcon}
                        </div>
                        <span class="text-xs text-gray-400 ml-2 whitespace-nowrap flex-shrink-0 project-label">${escapeHtml(project.name)}</span>
                    </div>
                </td>
                <td class="text-sm whitespace-nowrap">${task.estimatedTime || 0} 分</td>
                <td class="text-sm whitespace-nowrap">${actualTimeDisplay}</td>
                <td class="text-sm whitespace-nowrap font-mono">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>
                <td class="text-sm whitespace-nowrap font-mono">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>
                <td class="text-center space-x-1">
                    <button class="edit-task-btn text-gray-400 hover:text-blue-500 p-1" title="編集 (E)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="postpone-task-btn text-gray-400 hover:text-yellow-500 p-1" title="翌日に先送り (P)">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    </button>
                    <button class="delete-task-btn text-gray-400 hover:text-red-500 p-1" title="削除 (D)">
					    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
					</button>
                </td>
            `;
            tbody.appendChild(tr);
        });

        tableContainer.appendChild(table);
        wrapper.appendChild(tableContainer);
        container.appendChild(wrapper);

        attachTaskEventListeners();
        setupDragAndDrop('.task-row', tasks);
    }

    function renderTaskCards(container) {
        const tasks = getTasksForViewDate();
        const wrapper = document.createElement('div');
        wrapper.className = 'task-card-wrapper';

        tasks.forEach((task, index) => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const card = document.createElement('div');
            const isCompleted = task.status === 'completed';
            card.className = `task-card bg-white p-3 mt-2 shadow border-l-4 ${isCompleted ? 'completed' : ''} ${task.status === 'running' ? 'bg-blue-50' : ''} ${task.id === state.focusedTaskId ? 'focused' : ''}`;
            card.style.borderLeftColor = project.color;
            card.dataset.taskId = task.id;
            card.dataset.index = index;
            card.draggable = true;

            const isRunning = task.status === 'running';
            let timerButtonHtml = '';
            if (isCompleted) {
                 timerButtonHtml = `
                 <button class="timer-btn checkmark-btn rounded-full bg-gray-200 hover:bg-gray-300 cursor-pointer items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-600" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                </button>`;
            } else {
                timerButtonHtml = `<button class="timer-btn rounded-full transition-colors duration-200 flex-shrink-0 ${isRunning ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}">
                    ${isRunning ? '■' : '▶'}
                </button>`;
            }

            const memoIcon = task.memo ? `
                 <span class="tooltip-container memo-icon-clickable" data-task-id="${task.id}">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 text-gray-400 cursor-pointer hover:text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                    <span class="custom-tooltip">${escapeHtml(task.memo)}</span>
                </span>` : '';

            card.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="flex flex-col items-center">
                        ${timerButtonHtml}
						<div class="drag-handle text-gray-400 hover:text-gray-600 cursor-move mt-1">⋮⋮</div>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-start">
                             <h3 class="font-semibold text-base truncate flex items-center pr-2" title="${escapeHtml(task.name || '')}">
                               ${formatTaskName(task.name)}
                               ${memoIcon}
                            </h3>
                             <div class="flex space-x-1 flex-shrink-0">
                                <button class="edit-task-btn text-gray-400 hover:text-blue-500 p-1">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                                </button>
                                <button class="postpone-task-btn text-gray-400 hover:text-yellow-500 p-1">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                                </button>
                                <button class="delete-task-btn text-gray-400 hover:text-red-500 p-1">
								    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
								</button>
                            </div>
                        </div>
                        <p class="text-sm text-gray-500">${escapeHtml(project.name)}</p>
                        <div class="flex items-center justify-between text-xs text-gray-600 mt-1">
                            <div class="flex space-x-3">
                                <span>見積: ${task.estimatedTime || 0}分</span>
                            </div>
                            <div class="font-mono text-gray-400">
                                ${task.startTime ? formatClockTime(new Date(task.startTime)) : ''}
                                ${task.endTime ? ' - ' + formatClockTime(new Date(task.endTime)) : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            wrapper.appendChild(card);
        });

        container.appendChild(wrapper);
        attachTaskEventListeners();
        setupDragAndDrop('.task-card', tasks);
    }

    function renderArchive() {
        const dateView = document.getElementById('archive-date-view');
        const projectView = document.getElementById('archive-project-view');
		const searchView = document.getElementById('archive-search-view');
        
        dateView.classList.toggle('hidden', state.archiveView !== 'date');
        projectView.classList.toggle('hidden', state.archiveView !== 'project');
        searchView.classList.toggle('hidden', state.archiveView !== 'search');

        if (state.archiveView === 'date') {
            renderArchiveDateView();
        } else if (state.archiveView === 'project')  {
            updateArchiveProjectSelect();
            renderArchiveProjectView();
        } else if (state.archiveView === 'search') {
			const q = document.getElementById('archive-search-input').value.trim();
			renderArchiveSearchView(q);
		}
    }

    function renderArchiveDateView() {
        const dateEl = document.getElementById('archive-date');
        const listEl = document.getElementById('archive-tasks-list');
        const nextBtn = document.getElementById('next-archive-day');

        const dateObj = new Date(state.archiveViewDate);
        dateEl.textContent = dateObj.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });

        const tasksForDay = state.archivedTasks[state.archiveViewDate] || [];

        const tomorrow = new Date();
        nextBtn.disabled = state.archiveViewDate === getFormattedDate(tomorrow);
        nextBtn.classList.toggle('opacity-50', nextBtn.disabled);

        if (tasksForDay.length === 0) {
            listEl.innerHTML = '<p class="text-center text-gray-500 py-8">この日に完了したタスクはありません。</p>';
            return;
        }

        let tableHtml = '<table class="min-w-full bg-white">';
        tableHtml += `<thead class="bg-gray-50">
                    <tr>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">実績時間</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">開始</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">終了</th>
                        <th class="py-2 px-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">操作</th>
                    </tr>
                 </thead><tbody>`;

        tasksForDay.forEach(task => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const memoHtml = task.memo ? `<p class="text-xs text-gray-500 mt-1 whitespace-pre-wrap pl-4">${escapeHtml(task.memo)}</p>` : '';
            tableHtml += `
                <tr class="border-b">
                    <td class="py-2 px-3 task-memo-cell">
                        <div class="flex items-center space-x-2">
                           <span class="inline-block w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${project.color};"></span>
                           <div>
                             <span class="font-semibold">${formatTaskName(task.name)}</span>
                             <span class="text-xs text-gray-400 ml-2">${escapeHtml(project.name)}</span>
                           </div>
                        </div>
                        ${memoHtml}
                    </td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">
                         ${formatTime(calculateActualTime(task))}
                    </td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>
                    <td class="py-2 px-3 text-center space-x-1">
                        <button class="edit-archived-task-btn text-gray-400 hover:text-blue-500 p-1" data-task-id="${task.id}" data-date-key="${state.archiveViewDate}" title="編集">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                        </button>
                        <button class="delete-archived-task-btn text-gray-400 hover:text-red-500 p-1" data-task-id="${task.id}" data-date-key="${state.archiveViewDate}" title="削除">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </td>
                </tr>
            `;
        });

        tableHtml += '</tbody></table>';
        listEl.innerHTML = `<div class="archive-table-wrapper">${tableHtml}</div>`;
        attachArchiveEventListeners();
    }

    function updateArchiveProjectSelect() {
        const select = document.getElementById('archive-project-select');
        select.innerHTML = '<option value="">プロジェクトを選択</option>';
        state.projects.forEach(project => {
            select.innerHTML += `<option value="${project.id}">${escapeHtml(project.name)}</option>`;
        });
        if (state.selectedArchiveProject) {
            select.value = state.selectedArchiveProject;
        }
    }

    function renderArchiveProjectView() {
        const container = document.getElementById('archive-project-tasks');
        
        if (!state.selectedArchiveProject) {
            container.innerHTML = '<p class="text-center text-gray-500 py-8">プロジェクトを選択してください。</p>';
            return;
        }

        const selectedProject = state.projects.find(p => p.id === state.selectedArchiveProject);
        if (!selectedProject) {
            container.innerHTML = '<p class="text-center text-gray-500 py-8">選択されたプロジェクトが見つかりません。</p>';
            return;
        }

        const projectTasks = {};
        Object.keys(state.archivedTasks).forEach(date => {
            const tasksForDate = state.archivedTasks[date].filter(task => task.projectId === state.selectedArchiveProject);
            if (tasksForDate.length > 0) {
                projectTasks[date] = tasksForDate;
            }
        });

        const sortedDates = Object.keys(projectTasks).sort().reverse();

        if (sortedDates.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">「${escapeHtml(selectedProject.name)}」で完了したタスクはありません。</p>`;
            return;
        }

        let html = '';
        sortedDates.forEach(date => {
            const dateObj = new Date(date);
            const dateLabel = dateObj.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
            
            html += `<div class="mb-6">
                        <h3 class="font-bold text-lg mb-3 pb-2 border-b" style="color: ${selectedProject.color}">${dateLabel}</h3>
                        <div class="space-y-2">`;
            
            projectTasks[date].forEach(task => {
                const memoHtml = task.memo ? `<p class="text-xs text-gray-500 mt-1 whitespace-pre-wrap">${escapeHtml(task.memo)}</p>` : '';
                html += `
                    <div class="bg-gray-50 p-3 rounded">
                        <div class="flex justify-between items-start">
                            <div>
                                <span class="font-semibold">${formatTaskName(task.name)}</span>
                                ${memoHtml}
                            </div>
                            <span class="text-sm font-mono text-gray-600">
                                ${formatTime(calculateActualTime(task))}
                            </span>
                        </div>
                    </div>
                `;
            });
            
            html += `</div></div>`;
        });

        container.innerHTML = html;
    }

    function renderArchiveSearchView(query) {
        const container = document.getElementById('archive-search-results');
        const q = (query || '').trim();
        if (!q) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">検索語を入力して「検索」ボタンを押してください。</p>`;
            return;
        }

        const normalized = q.toLowerCase();
        const results = [];

        Object.entries(state.archivedTasks).forEach(([dateKey, tasks]) => {
            tasks.forEach(task => {
                const name = (task.name || '').toLowerCase();
                const memo = (task.memo || '').toLowerCase();
                if (name.includes(normalized) || memo.includes(normalized)) {
                    results.push({ date: dateKey, task });
                }
            });
        });

        if (results.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">「${escapeHtml(q)}」に一致するアーカイブ済みタスクは見つかりませんでした。</p>`;
            return;
        }

        results.sort((a, b) => (a.date < b.date ? 1 : a.date > b.date ? -1 : 0));

        let tableHtml = '<table class="min-w-full bg-white"><thead class="bg-gray-50"><tr>';
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">完了日</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">プロジェクト</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">実績時間</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">開始</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">終了</th>`;
        tableHtml += `</tr></thead><tbody>`;

        results.forEach(({ date, task }) => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const memoHtml = task.memo ? `<div class="text-xs text-gray-500 mt-1 whitespace-pre-wrap">${escapeHtml(task.memo)}</div>` : '';
            const dateLabel = new Date(date).toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', weekday: 'short' });

            tableHtml += `<tr class="border-b">`;
            tableHtml += `<td class="py-2 px-3">${dateLabel}</td>`;
            tableHtml += `<td class="py-2 px-3 task-memo-cell">${formatTaskName(task.name)}${memoHtml}</td>`;
            tableHtml += `<td class="py-2 px-3">${escapeHtml(project.name)}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${formatTime(calculateActualTime(task))}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>`;
            tableHtml += `</tr>`;
        });

        tableHtml += '</tbody></table>';
        container.innerHTML = `<div class="archive-table-wrapper">${tableHtml}</div>`;
    }

    function attachTaskEventListeners() {
        document.querySelectorAll('.task-row, .task-card').forEach(el => {
            el.addEventListener('click', (e) => {
                if (e.target.closest('button, a, .memo-icon-clickable')) {
                    return;
                }
                const taskId = e.currentTarget.dataset.taskId;
                if (state.focusedTaskId !== taskId) {
                    state.focusedTaskId = taskId;
                    renderTodayTasks();
                }
            });
        });

        document.querySelectorAll('.timer-btn, .checkmark-btn').forEach(btn => 
            btn.addEventListener('click', (e) => toggleTimer(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.delete-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => deleteTask(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.postpone-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => postponeTask(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.edit-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => openTaskEditModal(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        
        document.querySelectorAll('.memo-icon-clickable').forEach(icon => 
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                openMemoEditModal(e.currentTarget.dataset.taskId);
            })
        );
    }

    function attachArchiveEventListeners() {
        document.querySelectorAll('.edit-archived-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => openArchivedTaskEditModal(e.currentTarget.dataset.dateKey, e.currentTarget.dataset.taskId))
        );
        document.querySelectorAll('.delete-archived-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => deleteArchivedTask(e.currentTarget.dataset.dateKey, e.currentTarget.dataset.taskId))
        );
    }
    
    function setupDragAndDrop(selector, list) {
        const elements = document.querySelectorAll(selector);
        let draggedIndex = null;
        
        elements.forEach(el => {
            el.addEventListener('dragstart', (e) => {
                draggedIndex = parseInt(el.dataset.index, 10);
                e.dataTransfer.setData('text/plain', draggedIndex);
                setTimeout(() => el.classList.add('dragging'), 0);
            });

            el.addEventListener('dragend', (e) => {
                el.classList.remove('dragging');
                draggedIndex = null;
                 document.querySelectorAll('.drag-over').forEach(item => item.classList.remove('drag-over'));
            });

            el.addEventListener('dragover', (e) => {
                e.preventDefault();
                const target = e.target.closest(selector);
                if (target && parseInt(target.dataset.index, 10) !== draggedIndex) {
                    document.querySelectorAll('.drag-over').forEach(item => item.classList.remove('drag-over'));
                    target.classList.add('drag-over');
                }
            });

            el.addEventListener('dragleave', (e) => {
                e.target.closest(selector)?.classList.remove('drag-over');
            });

            el.addEventListener('drop', (e) => {
                e.preventDefault();
                const target = e.target.closest(selector);
                target?.classList.remove('drag-over');
                
                const fromIndex = draggedIndex;
                const toIndex = parseInt(target.dataset.index, 10);
                
                if (fromIndex !== null && fromIndex !== toIndex) {
                    const movedItem = list.splice(fromIndex, 1)[0];
                    list.splice(toIndex, 0, movedItem);
                    saveAndRender();
                }
            });
        });
    }

	function openAddTaskModal() {
	    document.getElementById('new-task-name').value = '';
	    document.getElementById('new-task-time').value = '5';
	    document.getElementById('new-task-project').value = '';
	    openModal('add-task-modal');
		const input = document.getElementById('new-task-name');
	    input.focus();
	}
    
    function openTaskEditModal(id) {
        const task = getTasksForViewDate().find(t => t.id === id);
        if (!task) return;

        state.editingTaskId = id;
        document.getElementById('edit-task-name').value = task.name || '';
        document.getElementById('edit-task-time').value = task.estimatedTime || 0;
        updateProjectDropdowns();
        document.getElementById('edit-task-project').value = task.projectId || '';
        document.getElementById('edit-task-memo').value = task.memo || '';
        
        const startTimeInput = document.getElementById('edit-task-startTime');
        const endTimeInput = document.getElementById('edit-task-endTime');
        
        startTimeInput.value = task.startTime ? new Date(task.startTime).toTimeString().slice(0, 5) : '';
        endTimeInput.value = task.endTime ? new Date(task.endTime).toTimeString().slice(0, 5) : '';
        
        document.getElementById('create-repeat-from-task').style.display = 'block';
        openModal('task-edit-modal');
		const input = document.getElementById('edit-task-name');
        input.focus();
    }
    
    function openArchivedTaskEditModal(dateKey, taskId) {
        if (!state.archivedTasks[dateKey]) return;
        const task = state.archivedTasks[dateKey].find(t => t.id === taskId);
        if (!task) return;

        state.editingTaskId = taskId;
        state.editingTaskDateKey = dateKey; 

        document.getElementById('edit-task-name').value = task.name || '';
        document.getElementById('edit-task-time').value = task.estimatedTime || 0;
        updateProjectDropdowns();
        document.getElementById('edit-task-project').value = task.projectId || '';
        document.getElementById('edit-task-memo').value = task.memo || '';
        
        const startTimeInput = document.getElementById('edit-task-startTime');
        const endTimeInput = document.getElementById('edit-task-endTime');
        
        startTimeInput.value = task.startTime ? new Date(task.startTime).toTimeString().slice(0, 5) : '';
        endTimeInput.value = task.endTime ? new Date(task.endTime).toTimeString().slice(0, 5) : '';
        
        document.getElementById('create-repeat-from-task').style.display = 'none';
        openModal('task-edit-modal');
		const input = document.getElementById('edit-task-name');
        input.focus();
    }


	function openMemoEditModal(id) {
	    const task = getTasksForViewDate().find(t => t.id === id);
	    if (!task) return;
	
	    state.editingMemoTaskId = id;
	    const memoTextEl = document.getElementById('edit-memo-text');
	    memoTextEl.value = task.memo || '';
	    openModal('memo-edit-modal');
	    memoTextEl.focus();
	}


    function saveMemoEdit() {
        const task = getTasksForViewDate().find(t => t.id === state.editingMemoTaskId);
        if (!task) return;

        const memo = document.getElementById('edit-memo-text').value.trim();
        task.memo = memo;

        closeModal('memo-edit-modal');
        saveAndRender();
    }

    function saveTaskEdit() {
        const tasks = state.editingTaskDateKey 
            ? state.archivedTasks[state.editingTaskDateKey] 
            : getTasksForViewDate();
        
        if (!tasks) {
            closeModal('task-edit-modal');
            return;
        }

        const task = tasks.find(t => t.id === state.editingTaskId);
        if (!task) {
            closeModal('task-edit-modal');
            return;
        }

        const name = document.getElementById('edit-task-name').value.trim();
        const time = parseInt(document.getElementById('edit-task-time').value, 10);
        const projectId = document.getElementById('edit-task-project').value || null;
        const memo = document.getElementById('edit-task-memo').value.trim();

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        task.name = name;
        task.estimatedTime = time;
        task.projectId = projectId;
        task.memo = memo;

        const startTimeValue = document.getElementById('edit-task-startTime').value;
        const endTimeValue = document.getElementById('edit-task-endTime').value;

        if (startTimeValue) {
            const baseDate = task.startTime ? new Date(task.startTime) : (task.createdDate ? new Date(task.createdDate) : new Date());
            const [hours, minutes] = startTimeValue.split(':');
            baseDate.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
            task.startTime = baseDate.toISOString();
        } else {
            task.startTime = null;
        }

        if (endTimeValue) {
            const baseDate = task.endTime ? new Date(task.endTime) : (task.startTime ? new Date(task.startTime) : new Date());
            const [hours, minutes] = endTimeValue.split(':');
            baseDate.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
            task.endTime = baseDate.toISOString();
        } else {
            task.endTime = null;
        }
        
        task.actualTime = calculateActualTime(task);
        
        if (!state.editingTaskDateKey) {
            updateTaskStatus(task);
        }

        closeModal('task-edit-modal');
        saveAndRender();
    }

    function createRepeatFromTask() {
        const task = getTasksForViewDate().find(t => t.id === state.editingTaskId);
        if (!task) return;

        const name = document.getElementById('edit-task-name').value.trim();
        const time = parseInt(document.getElementById('edit-task-time').value, 10);
        const projectId = document.getElementById('edit-task-project').value || null;

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        state.repeatTasks.push({
            id: 'rt' + Date.now(),
            name: name,
            estimatedTime: time,
            projectId: projectId,
            memo: task.memo || '',
            type: 'daily',
            value: null,
            startDate: null
        });

        closeModal('task-edit-modal');
        alert('リピートタスクを作成しました（毎日設定）。リピートタスクタブで詳細を編集できます。');
        saveAndRender();
    }

    function openRepeatEditModal(id) {
        const repeatTask = state.repeatTasks.find(rt => rt.id === id);
        if (!repeatTask) return;

        state.editingRepeatId = id;
        document.getElementById('edit-repeat-name').value = repeatTask.name || '';
        document.getElementById('edit-repeat-time').value = repeatTask.estimatedTime || 0;
        updateProjectDropdowns();
        document.getElementById('edit-repeat-project').value = repeatTask.projectId || '';
        document.getElementById('edit-repeat-memo').value = repeatTask.memo || '';
        document.getElementById('edit-repeat-type').value = repeatTask.type || 'daily';

        const weeklyContainer = document.getElementById('edit-repeat-weekly-options');
        if (weeklyContainer.childElementCount === 0) {
            ['日','月','火','水','木','金','土'].forEach((d, i) => {
                weeklyContainer.innerHTML += `<label class="inline-flex items-center mr-3"><input type="checkbox" value="${i}"><span class="ml-2 text-sm">${d}</span></label>`;
            });
        }

        document.querySelectorAll('#edit-repeat-weekly-options input').forEach(cb => cb.checked = false);
        document.getElementById('edit-repeat-monthly-day').value = '';
        document.getElementById('edit-repeat-interval-days').value = '';
        document.getElementById('edit-repeat-interval-start-date').value = '';

        if (repeatTask.type === 'weekly' && Array.isArray(repeatTask.value)) {
            document.querySelectorAll('#edit-repeat-weekly-options input').forEach(cb => {
                cb.checked = repeatTask.value.includes(parseInt(cb.value, 10));
            });
        } else if (repeatTask.type === 'monthly') {
            document.getElementById('edit-repeat-monthly-day').value = repeatTask.value || '';
        } else if (repeatTask.type === 'interval') {
            document.getElementById('edit-repeat-interval-days').value = repeatTask.value || '';
            document.getElementById('edit-repeat-interval-start-date').value = repeatTask.startDate || '';
        }

        document.getElementById('edit-repeat-weekly-options').classList.toggle('hidden', repeatTask.type !== 'weekly');
        document.getElementById('edit-repeat-monthly-options').classList.toggle('hidden', repeatTask.type !== 'monthly');
        document.getElementById('edit-repeat-interval-options').classList.toggle('hidden', repeatTask.type !== 'interval');
        openModal('repeat-edit-modal');

		const input = document.getElementById('edit-repeat-name');
		input.focus();
    }

    function saveRepeatEdit() {
        const repeatTask = state.repeatTasks.find(rt => rt.id === state.editingRepeatId);
        if (!repeatTask) return;

        const name = document.getElementById('edit-repeat-name').value.trim();
        const time = parseInt(document.getElementById('edit-repeat-time').value, 10);
        const projectId = document.getElementById('edit-repeat-project').value || null;
        const memo = document.getElementById('edit-repeat-memo').value.trim();
        const type = document.getElementById('edit-repeat-type').value;

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        let value = null;
        let startDate = repeatTask.startDate || null;

        if (type === 'weekly') {
            value = Array.from(document.querySelectorAll('#edit-repeat-weekly-options input:checked')).map(cb => parseInt(cb.value, 10));
            if (value.length === 0) { alert('曜日を選択してください。'); return; }
        } else if (type === 'monthly') {
            value = parseInt(document.getElementById('edit-repeat-monthly-day').value, 10);
            if (isNaN(value) || value < 1 || value > 31) { alert('有効な日付を入力してください。'); return; }
        } else if (type === 'interval') {
            value = parseInt(document.getElementById('edit-repeat-interval-days').value, 10);
            if (isNaN(value) || value < 1) { alert('有効な間隔（日数）を入力してください。'); return; }
            const startDateInput = document.getElementById('edit-repeat-interval-start-date').value;
            if (startDateInput) {
                startDate = startDateInput;
            } else if (!startDate) {
                startDate = new Date().toISOString().slice(0,10);
            }
        }

        repeatTask.name = name;
        repeatTask.estimatedTime = time;
        repeatTask.projectId = projectId;
        repeatTask.memo = memo;
        repeatTask.type = type;
        repeatTask.value = value;
        repeatTask.startDate = startDate;

        closeModal('repeat-edit-modal');
        saveAndRender();
    }

    function renderProjects() {
        const container = document.getElementById('projects-container');
        if (isMobile()) {
            renderProjectCards(container);
        } else {
            renderProjectTable(container);
        }
    }

    function renderProjectTable(container) {
        container.innerHTML = `<div class="overflow-x-auto">
            <table class="min-w-full bg-white">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="py-2 px-4 border-b w-8"></th>
                        <th class="py-2 px-4 border-b">プレビュー</th>
                        <th class="py-2 px-4 border-b text-left">プロジェクト名</th>
                        <th class="py-2 px-4 border-b">操作</th>
                    </tr>
                </thead>
                <tbody id="projects-list"></tbody>
            </table>
        </div>`;
        const list = document.getElementById('projects-list');
        list.innerHTML = '';
        state.projects.forEach((p, idx) => {
            const tr = document.createElement('tr');
            tr.className = 'border-b project-row';
            tr.dataset.id = p.id;
            tr.dataset.index = idx;
            tr.draggable = true;
            tr.innerHTML = `
                <td class="py-2 px-4 text-center"><span class="drag-handle">⋮⋮</span></td>
                <td class="pt-2 px-4 text-center"><span class="inline-block w-4 h-4 rounded-full" style="background-color: ${p.color};"></span></td>
                <td class="py-2 px-4">${escapeHtml(p.name)}</td>
                <td class="py-2 px-4 text-center space-x-1">
                    <button class="edit-project-btn text-gray-400 hover:text-blue-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="delete-project-btn text-gray-400 hover:text-red-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg>
                    </button>
                </td>
            `;
            list.appendChild(tr);
        });

        setupDragAndDrop('.project-row', state.projects);
        container.querySelectorAll('.edit-project-btn').forEach(btn => btn.addEventListener('click', (e) => editProject(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-project-btn').forEach(btn => btn.addEventListener('click', (e) => deleteProject(e.currentTarget.dataset.id)));
    }

    function renderProjectCards(container) {
        container.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'space-y-3';
        state.projects.forEach((p, idx) => {
            const card = document.createElement('div');
            card.className = 'bg-white p-3 shadow rounded-lg flex items-center gap-3 project-row';
            card.dataset.id = p.id;
            card.dataset.index = idx;
            card.draggable = true;
            card.innerHTML = `
                <span class="drag-handle text-gray-400 hover:text-gray-600 cursor-move">⋮⋮</span>
                <span class="inline-block w-5 h-5 rounded-full flex-shrink-0" style="background-color: ${p.color};"></span>
                <span class="flex-1 font-semibold truncate">${escapeHtml(p.name)}</span>
                <div class="space-x-1">
                    <button class="edit-project-btn text-gray-400 hover:text-blue-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="delete-project-btn text-gray-400 hover:text-red-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg>
                    </button>
                </div>
            `;
            wrapper.appendChild(card);
        });
        container.appendChild(wrapper);
        setupDragAndDrop('.project-row', state.projects);
        container.querySelectorAll('.edit-project-btn').forEach(btn => btn.addEventListener('click', (e) => editProject(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-project-btn').forEach(btn => btn.addEventListener('click', (e) => deleteProject(e.currentTarget.dataset.id)));
    }

    function renderRepeatTasks() {
        const container = document.getElementById('repeat-tasks-container');
        const weeklyOptionsContainer = document.getElementById('repeat-weekly-options');
        if (weeklyOptionsContainer.childElementCount === 0) {
            ['日','月','火','水','木','金','土'].forEach((d, i) => {
                weeklyOptionsContainer.innerHTML += `<label class="inline-flex items-center mr-3"><input type="checkbox" value="${i}"><span class="ml-2 text-sm">${d}</span></label>`;
            });
        }

        if (isMobile()) {
            renderRepeatTaskCards(container);
        } else {
            renderRepeatTaskTable(container);
        }
    }

    function renderRepeatTaskTable(container) {
        container.innerHTML = `<div class="overflow-x-auto">
            <table class="min-w-full bg-white">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="py-2 px-4 border-b w-8"></th>
                        <th class="py-2 px-4 border-b text-left">タスク名</th>
                        <th class="py-2 px-4 border-b text-left">プロジェクト</th>
                        <th class="py-2 px-4 border-b text-left">見積時間</th>
                        <th class="py-2 px-4 border-b text-left">繰り返し</th>
                        <th class="py-2 px-4 border-b">操作</th>
                    </tr>
                </thead>
                <tbody id="repeat-tasks-list"></tbody>
            </table>
        </div>`;
        const list = container.querySelector('#repeat-tasks-list');
        list.innerHTML = '';
        
        state.repeatTasks.forEach((rt, idx) => {
            const project = state.projects.find(p => p.id === rt.projectId) || { name: 'N/A' };
            let repeatText = '';
            if (rt.type === 'daily') repeatText = '毎日';
            else if (rt.type === 'weekly') repeatText = `毎週 ${Array.isArray(rt.value) ? rt.value.map(i => ['日','月','火','水','木','金','土'][i]).join(',') : ''}`;
            else if (rt.type === 'monthly') repeatText = `毎月 ${rt.value}日`;
            else if (rt.type === 'interval') repeatText = `${rt.value}日ごと (基準日: ${rt.startDate || '未設定'})`;

            const memoIcon = rt.memo ? `<span class="tooltip-container"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(rt.memo)}</span></span>` : '';

            const tr = document.createElement('tr');
            tr.className = 'border-b repeat-task-row';
            tr.dataset.id = rt.id;
            tr.dataset.index = idx;
            tr.draggable = true;
            tr.innerHTML = `
                <td class="py-2 px-4 text-center"><span class="drag-handle">⋮⋮</span></td>
                <td class="py-2 px-4"><div class="flex items-center">${formatTaskName(rt.name)}${memoIcon}</div></td>
                <td class="py-2 px-4">${escapeHtml(project.name)}</td>
                <td class="py-2 px-4">${rt.estimatedTime} 分</td>
                <td class="py-2 px-4 text-sm">${escapeHtml(repeatText)}</td>
                <td class="py-2 px-4 text-center space-x-1 whitespace-nowrap">
                    <button class="generate-single-repeat-btn text-gray-400 hover:text-green-500 p-1" data-id="${rt.id}" title="今日のタスクとして生成"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg></button>
                    <button class="edit-repeat-task-btn text-gray-400 hover:text-blue-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
                    <button class="delete-repeat-task-btn text-gray-400 hover:text-red-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg></button>
                </td>
            `;
            list.appendChild(tr);
        });
        
        setupDragAndDrop('.repeat-task-row', state.repeatTasks);
        container.querySelectorAll('.generate-single-repeat-btn').forEach(btn => btn.addEventListener('click', (e) => generateSingleRepeatTask(e.currentTarget.dataset.id)));
        container.querySelectorAll('.edit-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => openRepeatEditModal(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => deleteRepeatTask(e.currentTarget.dataset.id)));
    }

    function renderRepeatTaskCards(container) {
        container.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'space-y-3';
        state.repeatTasks.forEach((rt, idx) => {
            const project = state.projects.find(p => p.id === rt.projectId) || { name: 'N/A', color: '#cccccc' };
            let repeatText = '';
            if (rt.type === 'daily') repeatText = '毎日';
            else if (rt.type === 'weekly') repeatText = `毎週 ${Array.isArray(rt.value) ? rt.value.map(i => ['日','月','火','水','木','金','土'][i]).join(',') : ''}`;
            else if (rt.type === 'monthly') repeatText = `毎月 ${rt.value}日`;
            else if (rt.type === 'interval') repeatText = `${rt.value}日ごと`;

            const card = document.createElement('div');
            card.className = 'bg-white p-3 shadow border-l-4 repeat-task-row';
            card.style.borderLeftColor = project.color;
            card.dataset.id = rt.id;
            card.dataset.index = idx;
            card.draggable = true;

            const memoIcon = rt.memo ? `<span class="tooltip-container"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(rt.memo)}</span></span>` : '';

            card.innerHTML = `
                <div class="flex items-start gap-3">
                    <span class="drag-handle text-gray-400 hover:text-gray-600 cursor-move pt-1">⋮⋮</span>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-start">
                             <h3 class="font-semibold text-base flex items-center pr-2" title="${escapeHtml(rt.name || '')}">
                               ${formatTaskName(rt.name)} ${memoIcon}
                            </h3>
                             <div class="flex space-x-1 flex-shrink-0">
                                <button class="generate-single-repeat-btn text-gray-400 hover:text-green-500 p-1" data-id="${rt.id}" title="今日のタスクとして生成"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg></button>
                                <button class="edit-repeat-task-btn text-gray-400 hover:text-blue-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
                                <button class="delete-repeat-task-btn text-gray-400 hover:text-red-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg></button>
                            </div>
                        </div>
                        <p class="text-sm text-gray-500">${escapeHtml(project.name)}</p>
                        <div class="flex items-center justify-between text-xs text-gray-600 mt-1">
                            <span>見積: ${rt.estimatedTime || 0}分</span>
                            <span>${escapeHtml(repeatText)}</span>
                        </div>
                    </div>
                </div>
            `;
            wrapper.appendChild(card);
        });
        container.appendChild(wrapper);

        setupDragAndDrop('.repeat-task-row', state.repeatTasks);
        container.querySelectorAll('.generate-single-repeat-btn').forEach(btn => btn.addEventListener('click', (e) => generateSingleRepeatTask(e.currentTarget.dataset.id)));
        container.querySelectorAll('.edit-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => openRepeatEditModal(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => deleteRepeatTask(e.currentTarget.dataset.id)));
    }


    function updateProjectDropdowns() {
        const selects = document.querySelectorAll('#new-task-project, #repeat-task-project, #edit-task-project, #edit-repeat-project');
        selects.forEach(select => {
            const cur = select.value;
            select.innerHTML = '<option value="">プロジェクトなし</option>' + state.projects.map(p => `<option value="${p.id}">${escapeHtml(p.name)}</option>`).join('');
            if (cur) select.value = cur;
        });
    }

    function addTask(name = null, time = null, projectId = null, isInterrupt = false, options = {}) {
        const taskName = name.trim();
        const estimatedTime = parseInt(time, 10);
        
        if (!taskName || isNaN(estimatedTime) || estimatedTime < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return null;
        }

        const tasks = getTasksForViewDate();
        const newTask = {
            id: 't' + Date.now() + Math.random(),
            name: taskName,
            projectId: projectId || null,
            estimatedTime,
            actualTime: 0,
            status: 'pending',
            isInterrupt: !!isInterrupt,
            memo: '',
            startTime: null,
            endTime: null,
            createdDate: state.viewDate,
            ...options
        };

        let insertIndex = tasks.length;
        if (isInterrupt) {
            const firstPendingIndex = tasks.findIndex(t => t.status !== 'completed');
            insertIndex = firstPendingIndex === -1 ? 0 : firstPendingIndex;
		} else {
		        // 未実行(pending)タスクの最初の位置を探す
		        const firstPendingIndex = tasks.findIndex(t => t.status === 'pending');
		
		        if (firstPendingIndex !== -1) {
		            insertIndex = firstPendingIndex;
		        } else {
		            const lastRunningIndex = tasks.map(t => t.status).lastIndexOf('running');
		            if (lastRunningIndex !== -1) {
		                insertIndex = lastRunningIndex + 1;
		            } else {
		                insertIndex = tasks.length;
		            }
		        }
		  }
        tasks.splice(insertIndex, 0, newTask);
        setTasksForViewDate(tasks);

        state.focusedTaskId = newTask.id;
        saveAndRender();
        return newTask;
    }

    function deleteTask(id) {
        if (!confirm('このタスクを削除しますか？')) return;
        let tasks = getTasksForViewDate();
        const idx = tasks.findIndex(t => t.id === id);
        tasks = tasks.filter(t => t.id !== id);
        setTasksForViewDate(tasks);
        if (state.activeTaskId === id) stopActiveTimer();
        if (state.focusedTaskId === id) {
            const newFocusIndex = Math.min(idx, tasks.length - 1);
            state.focusedTaskId = tasks[newFocusIndex]?.id || null;
        }
        saveAndRender();
    }
    
    function deleteArchivedTask(dateKey, taskId) {
        if (!confirm('このアーカイブ済みタスクを削除しますか？この操作は元に戻せません。')) return;
        if (state.archivedTasks[dateKey]) {
            state.archivedTasks[dateKey] = state.archivedTasks[dateKey].filter(t => t.id !== taskId);
            if (state.archivedTasks[dateKey].length === 0) {
                delete state.archivedTasks[dateKey];
            }
        }
        saveAndRender();
    }
    
    function postponeTask(id) {
        let tasks = getTasksForViewDate();
        const taskIndex = tasks.findIndex(t => t.id === id);
        if (taskIndex === -1) return;
        
        const [taskToMove] = tasks.splice(taskIndex, 1);
        setTasksForViewDate(tasks);

        const nextDay = new Date(state.viewDate);
        nextDay.setDate(nextDay.getDate() + 1);
        const nextDateStr = getFormattedDate(nextDay);
        
        if (!state.dailyTasks[nextDateStr]) {
            state.dailyTasks[nextDateStr] = [];
        }
        state.dailyTasks[nextDateStr].unshift(taskToMove);

        if (state.activeTaskId === id) stopActiveTimer();
        if (state.focusedTaskId === id) {
            const newFocusIndex = Math.min(taskIndex, tasks.length - 1);
            state.focusedTaskId = tasks[newFocusIndex]?.id || null;
        }
        
        saveAndRender();
    }


    function toggleTimer(id, forceStop = false) {
        const tasks = getTasksForViewDate();
        const task = tasks.find(t => t.id === id);
        if (!task) return;

        if (state.activeTaskId === id && !forceStop) {
            task.endTime = new Date().toISOString();
            task.actualTime = calculateActualTime(task);
            updateTaskStatus(task);
            stopActiveTimer();
            const nextTask = tasks.find(t => t.status !== 'completed');
            state.focusedTaskId = nextTask ? nextTask.id : null;
        } 
        else {
            if (state.activeTaskId) {
                const runningTask = tasks.find(t => t.id === state.activeTaskId);
                if (runningTask) {
                    runningTask.endTime = new Date().toISOString();
                    runningTask.actualTime = calculateActualTime(runningTask);
                    updateTaskStatus(runningTask);
                }
                stopActiveTimer();
            }

            if (!forceStop) {
                if (task.startTime && task.status !== 'running') {
                    if (confirm('このタスクは既に一度開始されています。新しいタスクとして再開しますか？')) {
                        const newTask = addTask(task.name, task.estimatedTime, task.projectId, task.isInterrupt, {
                            memo: task.memo,
                            originRepeatId: task.originRepeatId
                        });
                        task.endTime = task.endTime || new Date().toISOString();
                        task.actualTime = calculateActualTime(task);
                        updateTaskStatus(task);
                        
                        toggleTimer(newTask.id);
                        return;
                    } else {
                         saveAndRender();
                         return;
                    }
                }
                
                task.startTime = task.startTime || new Date().toISOString();
                task.endTime = null;
                updateTaskStatus(task);
                state.activeTaskId = id;
                state.focusedTaskId = id;
                
                state.activeTimerId = setInterval(() => {
                    const timeEl = document.querySelector(`[data-task-id="${id}"] .time-actual`);
                    if (timeEl) {
                        timeEl.textContent = formatTime(calculateActualTime(task));
                    }
					const floatingTimeEl = document.getElementById('floating-elapsed-time');
				    if (floatingTimeEl) {
				        floatingTimeEl.textContent = formatTime(currentActualTime);
				    }
                }, 1000);
            }
        }
        saveAndRender();
    }

    function stopActiveTimer() {
        clearInterval(state.activeTimerId);
        state.activeTimerId = null;
        state.activeTaskId = null;
    }

    function addRepeatTask() {
        const name = document.getElementById('repeat-task-name').value.trim();
        const time = parseInt(document.getElementById('repeat-task-time').value, 10);
        const projectId = document.getElementById('repeat-task-project').value || null;
        const memo = document.getElementById('repeat-task-memo').value.trim();
        const type = document.getElementById('repeat-task-type').value;

        if (!name || isNaN(time) || time < 0) return alert('タスク名と見積時間を正しく入力してください。');

        let value;
        let startDate = null;
        if (type === 'weekly') {
            value = Array.from(document.querySelectorAll('#repeat-weekly-options input:checked')).map(cb => parseInt(cb.value, 10));
            if (value.length === 0) return alert('曜日を選択してください。');
        } else if (type === 'monthly') {
            value = parseInt(document.getElementById('repeat-monthly-day').value, 10);
            if (isNaN(value) || value < 1 || value > 31) return alert('有効な日付を入力してください。');
        } else if (type === 'interval') {
            value = parseInt(document.getElementById('repeat-interval-days').value, 10);
            if (isNaN(value) || value < 1) return alert('有効な間隔（日数）を入力してください。');
            const startDateInput = document.getElementById('repeat-interval-start-date').value;
            startDate = startDateInput ? startDateInput : new Date().toISOString().slice(0,10);
        }

        state.repeatTasks.push({ id: 'rt' + Date.now(), name, estimatedTime: time, projectId, memo, type, value, startDate });

        document.getElementById('repeat-task-name').value = '';
        document.getElementById('repeat-task-time').value = '';
        document.getElementById('repeat-task-memo').value = '';
        document.querySelectorAll('#repeat-weekly-options input').forEach(cb => cb.checked = false);
        document.getElementById('repeat-monthly-day').value = '';
        document.getElementById('repeat-interval-days').value = '';
        document.getElementById('repeat-interval-start-date').value = '';
        saveAndRender();
    }

    function deleteRepeatTask(id) {
        if (!confirm('このリピートタスクを削除しますか？')) return;
        state.repeatTasks = state.repeatTasks.filter(rt => rt.id !== id);
        saveAndRender();
    }

    function addProject() {
        const name = document.getElementById('project-name').value.trim();
        const color = document.getElementById('project-color').value;
        if (!name) { alert('プロジェクト名を入力してください。'); return; }
        state.projects.push({ id: 'p' + Date.now(), name, color });
        document.getElementById('project-name').value = '';
        saveAndRender();
    }

    function editProject(id) {
        const project = state.projects.find(p => p.id === id);
        if(!project) return;
        const newName = prompt('新しいプロジェクト名を入力してください:', project.name);
        if(newName && newName.trim()) {
            project.name = newName.trim();
        }
        const newColor = prompt('新しいカラーコード（例: #ff0000）を入力してください:', project.color);
        if(newColor && /^#[0-9A-Fa-f]{6}$/.test(newColor)) {
            project.color = newColor;
        }
        saveAndRender();
    }

    function deleteProject(id) {
        if (!confirm('このプロジェクトを削除しますか？')) return;
        state.projects = state.projects.filter(p => p.id !== id);
        Object.values(state.dailyTasks).flat().forEach(t => { if(t.projectId === id) t.projectId = null; });
        state.repeatTasks.forEach(rt => { if(rt.projectId === id) rt.projectId = null; });
        saveAndRender();
    }

    function exportData() {
        const exportData = {
            dailyTasks: state.dailyTasks,
            projects: state.projects,
            repeatTasks: state.repeatTasks,
            archivedTasks: state.archivedTasks,
            lastDate: state.lastDate,
            exportDate: new Date().toISOString()
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dtl_export_${new Date().toISOString().slice(0, 10)}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        alert('データをエクスポートしました。');
    }

    function importData() {
        const fileInput = document.getElementById('import-file');
        const file = fileInput.files[0];
        if (!file) return alert('インポートするファイルを選択してください。');
        
        if (!confirm('データをインポートします。IDが重複するデータは上書きされます。よろしいですか？')) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                
                Object.assign(state.dailyTasks, importedData.dailyTasks || {});
                Object.assign(state.archivedTasks, importedData.archivedTasks || {});

                if (importedData.projects && Array.isArray(importedData.projects)) {
                    const projectMap = new Map(state.projects.map(p => [p.id, p]));
                    importedData.projects.forEach(p => projectMap.set(p.id, p));
                    state.projects = Array.from(projectMap.values());
                }
                
                if (importedData.repeatTasks && Array.isArray(importedData.repeatTasks)) {
                    const repeatTaskMap = new Map(state.repeatTasks.map(rt => [rt.id, rt]));
                    importedData.repeatTasks.forEach(rt => repeatTaskMap.set(rt.id, rt));
                    state.repeatTasks = Array.from(repeatTaskMap.values());
                }

                state.lastDate = importedData.lastDate || state.lastDate;
                
                stopActiveTimer();
                state.viewDate = getFormattedDate(new Date());
                const tasksToday = getTasksForViewDate();
                state.focusedTaskId = tasksToday.length > 0 ? tasksToday[0].id : null;
                
                Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
                
                saveAndRender();
                alert('データをインポートしました。');
                fileInput.value = '';
            } catch (error) {
                alert('無効なファイル形式です。正しいJSONファイルを選択してください。');
                console.error('Import error:', error);
            }
        };
        reader.readAsText(file);
    }

    function clearAllData() {
        if (!confirm('本当に全てのデータを削除しますか？この操作は元に戻せません。')) return;
        if (!confirm('最終確認！全てのタスク、プロジェクト、履歴データが削除されます。')) return;
        
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('dtl_')) localStorage.removeItem(key);
        });
        
        location.reload();
    }

    function calculateAllEstimates() {
        const now = new Date();
        const unfinishedTasks = getTasksForViewDate().filter(t => t.status !== 'completed');
        const totalRemainingMinutes = unfinishedTasks.reduce((sum, task) => sum + (task.estimatedTime || 0), 0);
        totalEstimatedEndTimeEl.textContent = totalRemainingMinutes > 0 ? formatClockTime(new Date(now.getTime() + totalRemainingMinutes * 60 * 1000)) : '完了';
    }

	function renderFloatingTaskBar() {
	    const bar = document.getElementById('floating-task-bar');
	    if (!bar) return;
	
	    if (!isMobile() || document.querySelector('.modal.active')) {
	        bar.classList.remove('active');
	        return;
	    }
	
	    const tasks = getTasksForViewDate();
	    const activeTask = tasks.find(t => t.id === state.activeTaskId);
	
	    let barContent = '';
	    let shouldShowBar = false;
	
		// 実行中タスクの表示部分
		if (activeTask) {
		    shouldShowBar = true;
		    const estimatedEndTime = new Date(new Date(activeTask.startTime).getTime() + (activeTask.estimatedTime * 60 * 1000));
		    barContent = `
		        <button id="floating-timer-btn" class="timer-btn rounded-full bg-red-500 hover:bg-red-600 text-white flex-shrink-0" title="停止">■</button>
		        <div class="flex-1 min-w-0" onclick="document.querySelector('[data-task-id=\\'${activeTask.id}\\']')?.scrollIntoView({behavior: 'smooth', block: 'center'})">
		            <p class="text-sm font-bold truncate cursor-pointer hover:text-blue-600" title="${escapeHtml(activeTask.name)}">${formatTaskName(activeTask.name)}</p>
		            <div class="text-xs text-gray-600 flex justify-between font-mono">
		                <span><span class="sm:inline">終了予定: </span>${formatClockTime(estimatedEndTime)}</span>
		            </div>
		        </div>
		    `;
		} else {
		    // 次のタスクの表示部分
		    const nextTask = tasks.find(t => getTaskStatus(t) !== 'completed');
		    if (nextTask) {
		        shouldShowBar = true;
		        barContent = `
		            <button id="floating-timer-btn" class="timer-btn rounded-full bg-green-500 hover:bg-green-600 text-white flex-shrink-0" title="開始">▶</button>
		            <div class="flex-1 min-w-0" onclick="document.querySelector('[data-task-id=\\'${nextTask.id}\\']')?.scrollIntoView({behavior: 'smooth', block: 'center'})">
		                <p class="text-sm text-gray-500 cursor-pointer hover:text-blue-600">Next: <span class="font-bold text-gray-800 truncate" title="${escapeHtml(nextTask.name)}">${formatTaskName(nextTask.name)}</span></p>
		            </div>
		        `;
		    }
		}
	
	    if (shouldShowBar) {
	        bar.innerHTML = barContent;
	        bar.classList.add('active');
	        const timerBtn = document.getElementById('floating-timer-btn');
	        if (timerBtn) {
	            timerBtn.addEventListener('click', () => {
	                const targetTaskId = activeTask ? activeTask.id : tasks.find(t => getTaskStatus(t) !== 'completed')?.id;
	                if (targetTaskId) toggleTimer(targetTaskId);
	            });
	        }
	    } else {
	        bar.classList.remove('active');
	    }
	}

    function handleKeyboardShortcuts(e) {
        if (document.querySelector('input:focus, select:focus, textarea:focus, .modal.active')) return;
        
        const activeTab = document.querySelector('.tab-link.active').dataset.tab;

        if (activeTab === 'today') {
            handleTodayShortcuts(e);
        } else if (activeTab === 'archive') {
            handleArchiveShortcuts(e);
        }
    }

    function handleTodayShortcuts(e) {
        const tasks = getTasksForViewDate();
        const currentIndex = tasks.findIndex(t => t.id === state.focusedTaskId);

        switch(e.key.toLowerCase()) {
            case 'n': e.preventDefault(); openAddTaskModal(); break;
            case 'e': e.preventDefault(); if (state.focusedTaskId) openTaskEditModal(state.focusedTaskId); break;
            case 'm': e.preventDefault(); if (state.focusedTaskId) openMemoEditModal(state.focusedTaskId); break;
            case 'd': e.preventDefault(); if (state.focusedTaskId) deleteTask(state.focusedTaskId); break;
            case 'p': e.preventDefault(); if (state.focusedTaskId) postponeTask(state.focusedTaskId); break;
            case 'r':
                e.preventDefault();
                // ログイン中のみ同期を実行
               if (dailyTaskListApp.dbx) {
                    dailyTaskListApp.loadStateFromDropbox();
                }
                break;
            case 'arrowdown':
                e.preventDefault();
                if (e.ctrlKey || e.metaKey) {
                    if (currentIndex >= 0 && currentIndex < tasks.length - 1) {
                        [tasks[currentIndex], tasks[currentIndex + 1]] = [tasks[currentIndex + 1], tasks[currentIndex]];
                        setTasksForViewDate(tasks);
                        saveAndRender();
                    }
                } else {
                    if (currentIndex < tasks.length - 1) {
                        state.focusedTaskId = tasks[currentIndex + 1].id;
                        render();
                    }
                }
                break;
            case 'arrowup':
                 e.preventDefault();
                 if (e.ctrlKey || e.metaKey) {
                     if (currentIndex > 0) {
                        [tasks[currentIndex], tasks[currentIndex - 1]] = [tasks[currentIndex - 1], tasks[currentIndex]];
                        setTasksForViewDate(tasks);
                        saveAndRender();
                    }
                 } else {
                     if (currentIndex > 0) {
                        state.focusedTaskId = tasks[currentIndex - 1].id;
                        render();
                    }
                 }
                break;
            case 'arrowleft': e.preventDefault(); moveViewDate(-1); break;
            case 'arrowright': e.preventDefault(); moveViewDate(1); break;
            case ' ': e.preventDefault(); if(state.focusedTaskId) toggleTimer(state.focusedTaskId); break;
        }
    }

    function handleArchiveShortcuts(e) {
        switch(e.key) {
            case 'ArrowLeft': e.preventDefault(); if (state.archiveView === 'date') moveArchiveDate(-1); break;
            case 'ArrowRight': e.preventDefault(); if (state.archiveView === 'date') moveArchiveDate(1); break;
        }
    }
    
    function moveViewDate(direction) {
        const todayStr = getFormattedDate(new Date());
        if (direction === -1 && state.viewDate <= todayStr) {
            return;
        }
        const currentDate = new Date(state.viewDate);
        currentDate.setDate(currentDate.getDate() + direction);
        state.viewDate = getFormattedDate(currentDate);
        const tasks = getTasksForViewDate();
        state.focusedTaskId = tasks.length > 0 ? tasks[0].id : null;
        renderTodayTasks();
    }
    
    function moveArchiveDate(direction) {
        const currentDate = new Date(state.archiveViewDate);
        currentDate.setDate(currentDate.getDate() + direction);
        state.archiveViewDate = getFormattedDate(currentDate);
        renderArchive();
    }

    function escapeHtml(s) {
        if (!s) return '';
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }

    function formatTaskName(text) {
        if (!text) return '';
        let escapedText = escapeHtml(text);
        const markdownRegex = /\[(.*?)\]\((.*?)\)/g;
        escapedText = escapedText.replace(markdownRegex, (match, linkText, url) => {
            const safeUrl = url.replace(/&amp;/g, '&');
             return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${linkText}</a>`;
        });
        const urlRegex = /([a-zA-Z][a-zA-Z0-9+.-]*:\/\/\S+)/g;
        const parts = escapedText.split(/(<[^>]+>)/);
        return parts.map(part => {
             if (part.startsWith('<')) return part;
             return part.replace(urlRegex, url => {
                const safeUrl = url.replace(/&amp;/g, '&');
                return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${url}</a>`;
            });
        }).join('');
    }
    
    function calculateActualTime(task) {
        if (task.status === 'running' && task.startTime) {
             return Math.round((new Date().getTime() - new Date(task.startTime).getTime()) / 1000);
        }
        if (task.startTime && task.endTime) {
            const duration = new Date(task.endTime).getTime() - new Date(task.startTime).getTime();
            return Math.round(Math.max(0, duration) / 1000);
        }
        return task.actualTime || 0;
    }

    function saveAndRender() { saveState(); render(); updateTitle(); }
    function updateTimeDisplays() {
        currentDateEl.textContent = new Date().toLocaleString('ja-JP', { year:'numeric', month:'long', day:'numeric', weekday:'long' });
        calculateAllEstimates();
    }
    function formatTime(seconds) {
        const s = parseInt(seconds, 10) || 0;
        const h = Math.floor(s / 3600).toString().padStart(2,'0');
        const m = Math.floor((s % 3600) / 60).toString().padStart(2,'0');
        const sec = (s % 60).toString().padStart(2,'0');
        return `${h}:${m}:${sec}`;
    }
    function formatClockTime(date) {
        if (!date) return '--:--';
        return date.toLocaleTimeString('ja-JP', { hour:'2-digit', minute:'2-digit' });
    }

    init();
});
</script>

	
</body>
</html>
