<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CardBoard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f8fafc;
            font-family: 'Helvetica Neue', Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: default;
            overflow: hidden;
            touch-action: none;
        }

        #board {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            backface-visibility: hidden;
            -webkit-font-smoothing: antialiased;
        }

        .card {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 10px;
            min-width: 120px;
            max-width: 500px;
            min-height: 40px;
            cursor: move;
            border: 1px solid #e2e8f0;
            user-select: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: border-color 0.2s, box-shadow 0.2s;
            transform: translateZ(0);
        }

        .card:hover {
            border-color: #3b82f6;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        .card.editing {
            cursor: default;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .card-title {
            position: relative;
            z-index: 10; 
            font-weight: bold;
            font-size: 0.8rem;
            margin-bottom: 6px;
            border-bottom: 1px solid #f1f5f9;
            padding-bottom: 3px;
            outline: none;
            padding-right: 20px;
            word-break: break-all;
            white-space: pre-wrap;
            flex-shrink: 0;
            pointer-events: none;
        }

        .card.editing .card-title,
        .card.editing .card-body {
            pointer-events: auto;
            background: #fafafa;
            border-radius: 2px;
        }

        .card-body {
            position: relative;
            z-index: 1;
            font-size: 0.75rem;
            color: #334155;
            white-space: pre-wrap;
            outline: none;
            word-break: break-all;
            overflow: hidden;
            line-height: 1.5;
            padding-top: 2px;
            pointer-events: none;
            min-height: 0;
            max-height: calc(1.5em * 5);
            display: -webkit-box;
            -webkit-line-clamp: 5;
            -webkit-box-orient: vertical;
        }
        
        /* デフォルト状態でも本文が隠れている場合は...を表示 */
        .card-body::after {
            content: '...';
            position: absolute;
            bottom: 0;
            right: 0;
            background: white;
            padding-left: 3px;
            display: none;
        }
        
        .card.has-overflow .card-body::after {
            display: inline;
        }
        
        /* 手動リサイズされたカードは行数制限を解除するが、overflowは維持 */
        .card.resized .card-body {
            max-height: none;
            display: block;
            -webkit-line-clamp: unset;
            position: relative;
        }
        
        .card.editing .card-body {
            max-height: none;
            display: block;
            -webkit-line-clamp: unset;
        }
        
        .card.editing .card-body::after {
            display: none !important;
        }

        .card-body a {
            color: #2563eb;
            text-decoration: underline;
            pointer-events: auto;
            cursor: pointer;
            z-index: 11;
            position: relative;
        }

        /* グループのスタイル */
        .group {
            position: absolute;
            background: rgba(147, 197, 253, 0.08);
            border-radius: 12px;
            border: 2px solid #93c5fd;
            min-width: 200px;
            min-height: 150px;
            cursor: move;
            user-select: none;
            transition: border-color 0.2s, background 0.2s;
        }

        .group:hover {
            border-color: #60a5fa;
            background: rgba(147, 197, 253, 0.12);
        }

        .group.editing {
            cursor: default;
            border-color: #3b82f6;
            background: rgba(147, 197, 253, 0.15);
        }

        .group-title {
            position: absolute;
            top: 8px;
            left: 12px;
            font-weight: bold;
            font-size: 0.9rem;
            color: #1e40af;
            outline: none;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            background: transparent;
        }

        .group.editing .group-title {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.9);
        }

        .resizer {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 14px;
            height: 14px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #cbd5e1 50%);
            border-radius: 0 0 8px 0;
            opacity: 0;
            z-index: 20;
        }

        .card:hover .resizer,
        .group:hover .resizer {
            opacity: 1;
        }

        .group .resizer {
            background: linear-gradient(135deg, transparent 50%, #93c5fd 50%);
            border-radius: 0 0 12px 0;
        }

        .delete-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 18px;
            height: 18px;
            background: #fff;
            color: #94a3b8;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            opacity: 0;
            z-index: 30;
            border: 1px solid #e2e8f0;
            pointer-events: auto;
        }

        .card:hover .delete-btn,
        .group:hover .delete-btn {
            opacity: 1;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            padding: 10px 20px;
            border-radius: 100px;
            box-shadow: 0 10px 25px -5px rgb(0 0 0 / 0.1);
            z-index: 10000;
            border: 1px solid #e2e8f0;
        }

        .btn {
            padding: 6px 16px;
            border-radius: 100px;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .btn-primary { background: #0f172a; color: white; }
        .btn-primary:hover { background: #334155; transform: translateY(-1px); }
        
        .btn-group { background: #1e40af; color: white; }
        .btn-group:hover { background: #2563eb; transform: translateY(-1px); }
        
        .instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #64748b;
            font-size: 0.7rem;
            pointer-events: none;
            z-index: 50;
            background: rgba(255, 255, 255, 0.7);
            padding: 6px 12px;
            border-radius: 8px;
        }
		/* 送信ボタンのスタイル */
		.send-poic-btn {
		    position: absolute;
		    top: 6px;
		    right: 28px;
		    width: 18px;
		    height: 18px;
		    background: #fff;
		    color: #8b5cf6;
		    border-radius: 4px;
		    display: flex;
		    align-items: center;
		    justify-content: center;
		    font-size: 12px;
		    font-weight: bold;
		    cursor: pointer;
		    opacity: 0;
		    z-index: 30;
		    border: 1px solid #e2e8f0;
		    pointer-events: auto;
		    transition: all 0.2s;
		}
		.card:hover .send-poic-btn {
		    opacity: 1;
		}
    </style>
</head>
<body>

<div class="instructions">
    Wクリック: 追加・編集 / ドラッグ: 移動 / Ctrl+ホイール: ズーム / Ctrl+V: OPML貼付
</div>

<div id="canvas-container">
    <div id="board"></div>
</div>

<div class="controls">
    <div class="flex items-center gap-2 border-r pr-4 border-gray-200">
        <button onclick="zoomAroundCenter(1/1.2)" class="p-1 hover:bg-gray-100 rounded-full w-8 h-8 flex items-center justify-center font-bold text-sm">－</button>
        <span id="zoom-level" class="text-xs font-mono w-10 text-center text-gray-600">100%</span>
        <button onclick="zoomAroundCenter(1.2)" class="p-1 hover:bg-gray-100 rounded-full w-8 h-8 flex items-center justify-center font-bold text-sm">＋</button>
        <button onclick="resetZoom()" class="text-[10px] text-blue-500 hover:underline px-2">1:1</button>
    </div>
    <span id="card-count" class="text-[10px] text-slate-400 font-bold tracking-wider min-w-[40px]">0 件</span>
    <button onclick="addCard()" class="btn btn-primary">カード追加</button>
    <button onclick="addGroup()" class="btn btn-group">グループ追加</button>
    <button onclick="copyOPML()" class="btn border border-slate-200 hover:bg-slate-50">OPMLコピー</button>
    <button onclick="clearBoard()" class="btn text-red-400 hover:bg-red-50">全削除</button>
</div>

<script>
    const container = document.getElementById('canvas-container');
    const board = document.getElementById('board');
    const zoomDisplay = document.getElementById('zoom-level');
    const cardCountDisplay = document.getElementById('card-count');
    const STORAGE_KEY = 'cardboard_v12_state';
    
    let state = {
        offsetX: 0,
        offsetY: 0,
        scale: 1,
        nodes: [],
        groups: [],
        maxZ: 1000
    };

    let draggingNode = null;
    let draggingElement = null;
    let draggingGroup = null; // ドラッグ中のグループを追跡
    let draggingGroupCards = []; // ドラッグ開始時にグループに含まれていたカード
    let resizingNode = null;
    let resizingElement = null;
    let dragStartX, dragStartY;
    let resizeStartW, resizeStartH;
    let edgeScrollInterval = null;
    const scrollEdgeSize = 50;
    const scrollSpeed = 10;

    function loadState() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            try {
                const data = JSON.parse(saved);
                state = { ...state, ...data };
                state.groups = state.groups || [];
                updateTransform();
                state.nodes.forEach(renderCard);
                state.groups.forEach(renderGroup);
                updateCounter();
            } catch(e) { console.error('Failed to load state', e); }
        }
    }

    function saveState() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function updateTransform() {
        board.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px) scale(${state.scale})`;
    }

    function updateCounter() {
        cardCountDisplay.innerText = `${state.nodes.length} 件`;
    }

    let isPanning = false; let panStartX, panStartY;
    container.onmousedown = (e) => {
        if (e.target === container && e.button === 0) {
            isPanning = true; panStartX = e.clientX; panStartY = e.clientY;
            container.style.cursor = 'grabbing';
        }
    };
    container.onmousemove = (e) => {
        if (isPanning) {
            state.offsetX += e.clientX - panStartX;
            state.offsetY += e.clientY - panStartY;
            panStartX = e.clientX; panStartY = e.clientY;
            updateTransform();
        }
    };
    container.onmouseup = () => { isPanning = false; container.style.cursor = 'default'; saveState(); };

    container.addEventListener('wheel', (e) => {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const delta = e.deltaY < 0 ? 1.1 : 1/1.1;
            const rect = container.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const wx = (mx - state.offsetX) / state.scale;
            const wy = (my - state.offsetY) / state.scale;
            state.scale *= delta;
            state.scale = Math.max(0.1, Math.min(5, state.scale));
            state.offsetX = mx - wx * state.scale;
            state.offsetY = my - wy * state.scale;
            updateTransform();
            zoomDisplay.innerText = Math.round(state.scale * 100) + '%';
            saveState();
        } else {
            // 通常のスクロールでボードを移動
            state.offsetX -= e.deltaX;
            state.offsetY -= e.deltaY;
            updateTransform();
            saveState();
        }
    }, { passive: false });

    function zoomAroundCenter(f) {
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 2;
        const wx = (cx - state.offsetX) / state.scale;
        const wy = (cy - state.offsetY) / state.scale;
        state.scale *= f;
        state.scale = Math.max(0.1, Math.min(5, state.scale));
        state.offsetX = cx - wx * state.scale;
        state.offsetY = cy - wy * state.scale;
        updateTransform();
        zoomDisplay.innerText = Math.round(state.scale * 100) + '%';
        saveState();
    }

    function resetZoom() {
        state.scale = 1;
        state.offsetX = 0;
        state.offsetY = 0;
        updateTransform();
        zoomDisplay.innerText = '100%';
        saveState();
    }

    loadState();

    function linkify(text) {
        // マークダウンのリンク記法 [text](url) を先に処理してプレースホルダーに置換
        const mdLinks = [];
        text = text.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, (match, linkText, url) => {
            const placeholder = `__MDLINK_${mdLinks.length}__`;
            mdLinks.push(`<a href="${url}" target="_blank" rel="noopener">${linkText}</a>`);
            return placeholder;
        });
        
        // 通常のURLをリンク化
        const urlPattern = /(https?:\/\/[^\s]+)/g;
        text = text.replace(urlPattern, '<a href="$1" target="_blank" rel="noopener">$1</a>');
        
        // プレースホルダーを実際のリンクに戻す
        mdLinks.forEach((link, i) => {
            text = text.replace(`__MDLINK_${i}__`, link);
        });
        
        return text;
    }

    function startEdit(el) {
        const isGroup = el.classList?.contains('group-title');
        const card = isGroup ? el.closest('.group') : el.closest('.card');
        
        // カードの本文を編集する場合、現在の高さを保存
        if (!isGroup && el.classList.contains('card-body')) {
            const cardId = card.id;
            const node = state.nodes.find(n => n.id === cardId);
            if (node) {
                // 編集前の高さを一時保存
                const currentHeight = card.offsetHeight;
                card.dataset.preEditHeight = card.style.height || '';
                // 現在の高さを最小値として設定し、コンテンツが長ければ広がる
                card.style.minHeight = `${currentHeight}px`;
                card.style.height = 'auto';
                el.textContent = node.body; // 保存されている生のテキストを表示
            }
        }
        
        card.classList.add('editing');
        el.contentEditable = "true";
        el.focus();
        // 全選択はしない（カーソルは自然にクリック位置に来る）
    }

    function endEdit(el) {
        const isGroup = el.classList?.contains('group-title');
        const card = isGroup ? el.closest('.group') : el.closest('.card');
        card.classList.remove('editing');
        el.contentEditable = "false";
        const id = card.id;
        
        if (isGroup) {
            const group = state.groups.find(g => g.id === id);
            if (group) {
                group.title = el.innerText;
                saveState();
            }
        } else {
            const node = state.nodes.find(n => n.id === id);
            if (!node) return;
            
            if (el.classList.contains('card-title')) {
                node.title = el.innerText;
            } else {
                // 生のテキストを保存
                node.body = el.innerText;
                // プレビュー表示に変換
                el.innerHTML = linkify(node.body);
                // 編集前の高さを復元し、min-heightをクリア
                if (card.dataset.preEditHeight !== undefined) {
                    card.style.height = card.dataset.preEditHeight;
                    card.style.minHeight = '';
                    delete card.dataset.preEditHeight;
                }
            }
            saveState();
        }
    }

    function renderCard(node) {
        const el = document.createElement('div');
        el.className = 'card';
        if (node.resized) el.classList.add('resized');
        el.id = node.id;
        el.style.left = `${node.x}px`;
        el.style.top = `${node.y}px`;
        el.style.zIndex = node.z || 1000;
        if (node.width) el.style.width = `${node.width}px`;
        if (node.height) el.style.height = `${node.height}px`;

        const titleEl = document.createElement('div');
        titleEl.className = 'card-title';
        titleEl.innerText = node.title;

        const bodyEl = document.createElement('div');
        bodyEl.className = 'card-body';
        bodyEl.innerHTML = linkify(node.body);

        titleEl.onblur = () => endEdit(titleEl);
        bodyEl.onblur = () => endEdit(bodyEl);

        titleEl.onkeydown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                endEdit(titleEl);
                startEdit(bodyEl);
            } else if (e.key === 'Tab') {
                e.preventDefault();
                endEdit(titleEl);
                startEdit(bodyEl);
            }
        };

        el.ondblclick = (e) => {
            e.stopPropagation();
            if (!el.classList.contains('editing')) {
                const rect = el.getBoundingClientRect();
                let targetEl;
                if ((e.clientY - rect.top) < 30) {
                    targetEl = titleEl;
                } else {
                    targetEl = bodyEl;
                }
                
                startEdit(targetEl);
                
                // ダブルクリックによるテキスト選択をキャンセル
                window.getSelection().removeAllRanges();
                
                // クリック位置にカーソルを配置
                setTimeout(() => {
                    const range = document.caretRangeFromPoint(e.clientX, e.clientY);
                    if (range) {
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }, 0);
            }
        };

        const del = document.createElement('div');
        del.className = 'delete-btn';
        del.innerHTML = '&times;';
        del.onclick = (e) => {
            e.stopPropagation();
            state.nodes = state.nodes.filter(n => n.id !== node.id);
            el.remove();
            saveState();
            updateCounter();
        };

		const sendBtn = document.createElement('div');
		    sendBtn.className = 'send-poic-btn';
		    sendBtn.innerHTML = '→';
		    sendBtn.title = 'd-PoICに送る';
		    sendBtn.onclick = (e) => {
		        e.stopPropagation();
		        sendToPoIC(node);
		};

        const resizer = document.createElement('div');
        resizer.className = 'resizer';

        el.append(titleEl, bodyEl, sendBtn, del, resizer);

        el.onmousedown = (e) => {
            if (e.target.closest('a') || e.target === del || el.classList.contains('editing')) return;
            
            state.maxZ++;
            node.z = state.maxZ;
            el.style.zIndex = node.z;

            if (e.target === resizer) {
                resizingNode = node; resizingElement = el;
                dragStartX = e.clientX; dragStartY = e.clientY;
                // widthが設定されている場合はそれを使用、なければoffsetWidthを使用して設定
                if (!node.width) {
                    node.width = el.offsetWidth;
                    el.style.width = `${node.width}px`;
                }
                if (!node.height) {
                    node.height = el.offsetHeight;
                    el.style.height = `${node.height}px`;
                }
                resizeStartW = node.width;
                resizeStartH = node.height;
                e.preventDefault(); e.stopPropagation(); return;
            }

            draggingNode = node; draggingElement = el;
            dragStartX = e.clientX; dragStartY = e.clientY;
            e.preventDefault();
        };

        board.appendChild(el);
        
        // すべてのカードでoverflowチェック
        setTimeout(() => {
            if (bodyEl.scrollHeight > bodyEl.clientHeight) {
                el.classList.add('has-overflow');
            }
        }, 0);
        
        return { el, titleEl, bodyEl };
    }

    function renderGroup(group) {
        const el = document.createElement('div');
        el.className = 'group';
        el.id = group.id;
        el.style.left = `${group.x}px`;
        el.style.top = `${group.y}px`;
        el.style.width = `${group.width}px`;
        el.style.height = `${group.height}px`;
        // グループは常にカードより後ろに配置
        el.style.zIndex = (group.z || 1000) - 5000;

        const titleEl = document.createElement('div');
        titleEl.className = 'group-title';
        titleEl.innerText = group.title;

        titleEl.onblur = () => endEdit(titleEl);
        
        titleEl.onkeydown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                endEdit(titleEl);
            }
        };

        el.ondblclick = (e) => {
            e.stopPropagation();
            if (!el.classList.contains('editing')) {
                startEdit(titleEl);
            }
        };

        const del = document.createElement('div');
        del.className = 'delete-btn';
        del.innerHTML = '&times;';
        del.onclick = (e) => {
            e.stopPropagation();
            // グループを削除（カードは削除しない）
            state.groups = state.groups.filter(g => g.id !== group.id);
            state.nodes.forEach(n => {
                if (n.groupId === group.id) delete n.groupId;
            });
            el.remove();
            saveState();
            updateCounter();
        };

        const resizer = document.createElement('div');
        resizer.className = 'resizer';

        el.append(titleEl, del, resizer);

        el.onmousedown = (e) => {
            if (e.target === del || el.classList.contains('editing')) return;
            
            // グループのz-indexは更新しない（常に背面）
            
            if (e.target === resizer) {
                resizingNode = group; resizingElement = el;
                dragStartX = e.clientX; dragStartY = e.clientY;
                // グループは常にwidth/heightが設定されているはずだが、念のため
                resizeStartW = group.width || el.offsetWidth;
                resizeStartH = group.height || el.offsetHeight;
                e.preventDefault(); e.stopPropagation(); return;
            }

            draggingNode = group; draggingElement = el;
            draggingGroup = group; // グループをドラッグ中であることを記録
            // ドラッグ開始時にグループ内にあるカードを記憶
            draggingGroupCards = getCardsInGroup(group);
            dragStartX = e.clientX; dragStartY = e.clientY;
            e.preventDefault();
        };

        board.appendChild(el);
        return { el, titleEl };
    }

    // グループ内のカードを判定する関数
    function getCardsInGroup(group) {
        return state.nodes.filter(node => {
            const cardCenterX = node.x + (node.width || 150) / 2;
            const cardCenterY = node.y + (node.height || 60) / 2;
            return cardCenterX >= group.x && 
                   cardCenterX <= group.x + group.width &&
                   cardCenterY >= group.y && 
                   cardCenterY <= group.y + group.height;
        });
    }

    window.onmousemove = (e) => {
        if (draggingNode) {
            const dx = (e.clientX - dragStartX) / state.scale;
            const dy = (e.clientY - dragStartY) / state.scale;
            draggingNode.x += dx;
            draggingNode.y += dy;
            draggingElement.style.left = `${draggingNode.x}px`;
            draggingElement.style.top = `${draggingNode.y}px`;
            
            // グループをドラッグ中の場合、ドラッグ開始時に含まれていたカードだけを移動
            if (draggingGroup && draggingGroupCards.length > 0) {
                draggingGroupCards.forEach(card => {
                    card.x += dx;
                    card.y += dy;
                    const cardEl = document.getElementById(card.id);
                    if (cardEl) {
                        cardEl.style.left = `${card.x}px`;
                        cardEl.style.top = `${card.y}px`;
                    }
                });
            }
            
            dragStartX = e.clientX; dragStartY = e.clientY;
            checkEdgeScroll(e.clientX, e.clientY);
        } else if (resizingNode) {
            const dw = (e.clientX - dragStartX) / state.scale;
            const dh = (e.clientY - dragStartY) / state.scale;
            // グループかカードかをIDで判定（グループは'g'で始まる）
            const isGroup = resizingNode.id.startsWith('g');
            const minSize = isGroup ? 200 : 120;
            const minHeight = isGroup ? 150 : 40;
            
            resizingNode.width = Math.max(minSize, resizeStartW + dw);
            resizingNode.height = Math.max(minHeight, resizeStartH + dh);
            resizingElement.style.width = `${resizingNode.width}px`;
            resizingElement.style.height = `${resizingNode.height}px`;
            
            // カードの場合、本文がoverflowしているかチェック
            if (!isGroup) {
                const bodyEl = resizingElement.querySelector('.card-body');
                if (bodyEl && bodyEl.scrollHeight > bodyEl.clientHeight) {
                    resizingElement.classList.add('has-overflow');
                } else {
                    resizingElement.classList.remove('has-overflow');
                }
            }
        }
    };

    window.onmouseup = () => {
        // リサイズが完了したら、カードに'resized'クラスを追加してフラグを保存
        if (resizingNode && resizingElement && !resizingNode.id.startsWith('g')) {
            resizingElement.classList.add('resized');
            resizingNode.resized = true;
        }
        
        // グループをドラッグし終わったときに、最終的にグループ内にあるカードのgroupIdを更新
        if (draggingGroup) {
            const cardsInGroup = getCardsInGroup(draggingGroup);
            // すべてのカードのgroupIdをクリア
            state.nodes.forEach(card => {
                if (card.groupId === draggingGroup.id) {
                    delete card.groupId;
                }
            });
            // 現在グループ内にあるカードにgroupIdを設定
            cardsInGroup.forEach(card => {
                card.groupId = draggingGroup.id;
            });
        }
        
        if (draggingNode || resizingNode) saveState();
        draggingNode = null; 
        draggingGroup = null;
        draggingGroupCards = [];
        resizingNode = null;
        resizingElement = null;
        stopEdgeScroll();
    };

    function checkEdgeScroll(mx, my) {
        stopEdgeScroll();
        let vx = 0, vy = 0;
        if (mx < scrollEdgeSize) vx = scrollSpeed;
        else if (mx > window.innerWidth - scrollEdgeSize) vx = -scrollSpeed;
        if (my < scrollEdgeSize) vy = scrollSpeed;
        else if (my > window.innerHeight - scrollEdgeSize) vy = -scrollSpeed;

        if (vx !== 0 || vy !== 0) {
            edgeScrollInterval = setInterval(() => {
                state.offsetX += vx;
                state.offsetY += vy;
                if (draggingNode) {
                    draggingNode.x -= vx / state.scale;
                    draggingNode.y -= vy / state.scale;
                    draggingElement.style.left = `${draggingNode.x}px`;
                    draggingElement.style.top = `${draggingNode.y}px`;
                    
                    // グループをドラッグ中の場合、グループ内のカードも一緒にスクロール
                    if (draggingGroup && draggingGroupCards.length > 0) {
                        draggingGroupCards.forEach(card => {
                            card.x -= vx / state.scale;
                            card.y -= vy / state.scale;
                            const cardEl = document.getElementById(card.id);
                            if (cardEl) {
                                cardEl.style.left = `${card.x}px`;
                                cardEl.style.top = `${card.y}px`;
                            }
                        });
                    }
                }
                updateTransform();
            }, 16);
        }
    }

    function stopEdgeScroll() {
        if (edgeScrollInterval) { clearInterval(edgeScrollInterval); edgeScrollInterval = null; }
    }

    function createCard(x, y, data = {}, autoEdit = false) {
        const node = {
            id: 'n' + Date.now() + Math.random(),
            x: x, y: y, z: ++state.maxZ,
            width: data.width || 250,
            height: data.height || 120,
            title: data.title || 'タイトル',
            body: data.body || '',
            groupId: data.groupId || null
        };
        state.nodes.push(node);
        const { titleEl } = renderCard(node);
        updateCounter();
        saveState();

        if (autoEdit) {
            setTimeout(() => {
                const cardEl = document.getElementById(node.id);
                cardEl.classList.add('editing');
                titleEl.contentEditable = "true";
                titleEl.focus();
                document.execCommand('selectAll', false, null);
            }, 10);
        }
        return node;
    }

    function createGroup(x, y, data = {}, autoEdit = false) {
        const group = {
            id: 'g' + Date.now() + Math.random(),
            x: x, y: y, z: ++state.maxZ,
            width: data.width || 300,
            height: data.height || 200,
            title: data.title || 'グループ'
        };
        state.groups.push(group);
        const { titleEl } = renderGroup(group);
        updateCounter();
        saveState();

        if (autoEdit) {
            setTimeout(() => {
                const groupEl = document.getElementById(group.id);
                groupEl.classList.add('editing');
                titleEl.contentEditable = "true";
                titleEl.focus();
                document.execCommand('selectAll', false, null);
            }, 10);
        }
        return group;
    }

    function addCard() {
        createCard((-state.offsetX + window.innerWidth/2 - 80)/state.scale, (-state.offsetY + window.innerHeight/2 - 30)/state.scale, {}, true);
    }

    function addGroup() {
        createGroup((-state.offsetX + window.innerWidth/2 - 150)/state.scale, (-state.offsetY + window.innerHeight/2 - 100)/state.scale, {}, true);
    }

    window.addEventListener('paste', (e) => {
        const text = e.clipboardData.getData('text');
        if (text.includes('<opml')) importOPML(text);
    });

    function importOPML(xml) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(xml, "text/xml");
        const rootElements = doc.querySelectorAll('body > outline');
        let curX = (-state.offsetX + 80) / state.scale;
        let curY = (-state.offsetY + 80) / state.scale;
        const stepX = 40; const stepY = 32; 
        let cardIdx = 0;

        function processOutline(outline) {
            const children = outline.querySelectorAll(':scope > outline');
            if (children.length > 0) {
                const title = outline.getAttribute('text') || '';
                const bodyLines = [];
                let maxLineChars = title.length;
                function extractBody(items, depth = 0) {
                    items.forEach(item => {
                        const txt = item.getAttribute('text') || '';
                        bodyLines.push("  ".repeat(depth) + txt);
                        maxLineChars = Math.max(maxLineChars, txt.length + (depth * 2));
                        const sub = item.querySelectorAll(':scope > outline');
                        if (sub.length > 0) extractBody(sub, depth + 1);
                    });
                }
                extractBody(children);
                const calculatedWidth = Math.min(320, Math.max(200, maxLineChars * 10 + 40));
                createCard(curX + (cardIdx * stepX), curY + (cardIdx * stepY), { 
                    title, body: bodyLines.join('\n'), width: calculatedWidth
                });
                cardIdx++;
            }
        }

        rootElements.forEach(root => {
            const subOutlines = root.querySelectorAll(':scope > outline');
            if (subOutlines.length > 0) subOutlines.forEach(processOutline);
            else { createCard(curX, curY, { title: root.getAttribute('text') || '', body: '' }); cardIdx++; }
        });
        showToast('インポート完了');
    }

    function clearBoard() {
        if (confirm('全てのカードとグループを削除しますか？')) {
            state.nodes = []; 
            state.groups = [];
            board.innerHTML = ''; 
            state.maxZ = 1000; 
            saveState(); 
            updateCounter();
        }
    }

    function copyOPML() {
        // グループ情報を含めてOPML生成
        const groupMap = {};
        state.groups.forEach(g => {
            const cardsInGroup = getCardsInGroup(g);
            // グループIDをカードに設定
            cardsInGroup.forEach(card => card.groupId = g.id);
            
            groupMap[g.id] = {
                group: g,
                cards: cardsInGroup
            };
        });

        // グループに属していないカードを取得
        const cardsInAnyGroup = new Set();
        Object.values(groupMap).forEach(({cards}) => {
            cards.forEach(c => cardsInAnyGroup.add(c.id));
        });
        
        const orphanCards = state.nodes.filter(n => !cardsInAnyGroup.has(n.id));

        // グループとカードを混在させて位置でソート
        const items = [];
        
        // グループを追加（グループの位置を基準）
        state.groups.forEach(g => {
            items.push({
                type: 'group',
                data: g,
                y: g.y,
                x: g.x
            });
        });
        
        // グループに属していないカードを追加
        orphanCards.forEach(card => {
            items.push({
                type: 'card',
                data: card,
                y: card.y,
                x: card.x
            });
        });
        
        // Y座標優先でソート
        items.sort((a, b) => {
            if (Math.abs(a.y - b.y) < 10) return a.x - b.x;
            return a.y - b.y;
        });

        let opml = `<?xml version="1.0" encoding="UTF-8"?><opml version="2.0"><body><outline text="CardBoard Export">`;
        
        items.forEach(item => {
            if (item.type === 'group') {
                const g = item.data;
                opml += `<outline text="${escapeXml(g.title)}">`;
                const cards = groupMap[g.id].cards.sort((a, b) => {
                    if (Math.abs(a.y - b.y) < 10) return a.x - b.x;
                    return a.y - b.y;
                });
                cards.forEach(card => {
                    opml += `<outline text="${escapeXml(card.title)}">`;
                    if (card.body) {
                        card.body.split('\n').forEach(line => {
                            if(line.trim()) opml += `<outline text="${escapeXml(line.trim())}"/>`;
                        });
                    }
                    opml += `</outline>`;
                });
                opml += `</outline>`;
            } else {
                const n = item.data;
                opml += `<outline text="${escapeXml(n.title)}">`;
                if (n.body) {
                    n.body.split('\n').forEach(line => {
                        if(line.trim()) opml += `<outline text="${escapeXml(line.trim())}"/>`;
                    });
                }
                opml += `</outline>`;
            }
        });
        
        opml += `</outline></body></opml>`;
        const textArea = document.createElement("textarea");
        textArea.value = opml;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showToast('OPMLをコピーしました');
    }

    function escapeXml(s) {
        return s.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":"&apos;"}[c]));
    }

    function showToast(m) {
        const t = document.createElement('div');
        t.className = "fixed top-4 right-4 bg-slate-800 text-white px-4 py-2 rounded-lg shadow-xl z-[10001] text-xs";
        t.innerText = m;
        document.body.appendChild(t);
        setTimeout(() => t.remove(), 2000);
    }

    container.ondblclick = (e) => {
        if(e.target === container) {
            const x = (e.clientX - state.offsetX) / state.scale;
            const y = (e.clientY - state.offsetY) / state.scale;
            createCard(x, y, {}, true);
        }
    };

	// d-PoICに送る関数
	function sendToPoIC(card) {
	    const cardData = {
	        title: card.title,
	        body: card.body,
	        type: 'Discovery', // CardBoardから来たものはDiscovery扱い
	        stacks: [],
	        createdAt: Date.now(),
	        updatedAt: Date.now()
	    };
	    
	    const jsonStr = JSON.stringify(cardData);
	    const encoded = btoa(encodeURIComponent(jsonStr));
	    
	    // d-PoICを開く
	    const poicUrl = `https://morvra.github.io/poic/?import=${encoded}`;
	    window.open(poicUrl, '_blank');
	}
	
</script>
</body>
</html>
